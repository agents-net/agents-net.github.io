{
  "api/Agents.Net.Agent.html": {
    "href": "api/Agents.Net.Agent.html",
    "title": "Class Agent | Agents.Net Documentation",
    "keywords": "Class Agent Base class for all agents. It is necessary to inherit this base class in order to receive messages from the IMessageBoard . Inheritance Object Agent InterceptorAgent Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public abstract class Agent : IDisposable Remarks The agents must define which messages they want to receive, intercept and which messages they produce. When messages are intercepted it is necessary to use the InterceptorAgent base class. Examples [Consumes(typeof(ConsumedMessage))] [Produces(typeof(ProducedMessage))] public class AgentImplementation : Agent { //Implementation } Constructors | Improve this Doc View Source Agent(IMessageBoard) Initialized a new instance of the class Agent . Declaration protected Agent(IMessageBoard messageBoard) Parameters Type Name Description IMessageBoard messageBoard The message board to send messages. Properties | Improve this Doc View Source Id The id of the agent. Declaration protected Guid Id { get; } Property Value Type Description Guid Remarks The id is only used for logging. Methods | Improve this Doc View Source AddDisposable(IDisposable) Thread-safely adds an for disposing on Dispose(Boolean) Declaration protected void AddDisposable(IDisposable disposable) Parameters Type Name Description IDisposable disposable The disposable to add. | Improve this Doc View Source Dispose() Declaration public void Dispose() | Improve this Doc View Source Dispose(Boolean) Dispose any resources that are stored in the message. Declaration protected virtual void Dispose(bool disposing) Parameters Type Name Description Boolean disposing If true it was called from the Dispose() method. | Improve this Doc View Source Execute(Message) This method is called by the message boards to execute a certain message. Declaration public void Execute(Message messageData) Parameters Type Name Description Message messageData The message data that is executed. Remarks Only messages which are defined with the ConsumesAttribute are passed to this method. Only the IMessageBoard should call this. It can also be used in unit tests. This method executes the ExecuteCore(Message) method with the provided message. Additionally it logs all received messages and throw an exception method if the ExecuteCore(Message) method throws an exception. | Improve this Doc View Source ExecuteCore(Message) The method which should be overridden by the implementation of the agent. It accepts the messages in the same way the Execute(Message) method does. Declaration protected abstract void ExecuteCore(Message messageData) Parameters Type Name Description Message messageData The received message. | Improve this Doc View Source OnMessage(Message) This method is used to send a single message to the message board. Declaration protected void OnMessage(Message message) Parameters Type Name Description Message message The message to send. Remarks The message will be send to the IMessageBoard which was passed in the constructor. | Improve this Doc View Source OnMessages(IReadOnlyCollection<Message>) This method is no deprecated. Please switch to the new SendAndAggregate(IReadOnlyCollection<TStart>, Action<Message>) method. Declaration protected void OnMessages(IReadOnlyCollection<Message> messages) Parameters Type Name Description IReadOnlyCollection < Message > messages All messages to be send. Remarks The message will be send to the IMessageBoard which was passed in the constructor. To accumulate all messages again it is necessary that all send messages are of the same type."
  },
  "api/Agents.Net.AgentLog.html": {
    "href": "api/Agents.Net.AgentLog.html",
    "title": "Class AgentLog | Agents.Net Documentation",
    "keywords": "Class AgentLog This class is used to log an agent interaction in JSON format. Inheritance Object AgentLog Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class AgentLog : object Remarks It can be used for analysing tests or the log. Constructors | Improve this Doc View Source AgentLog(String, String, Guid, MessageLog) Initialized a new instance of the class AgentLog . Declaration public AgentLog(string agent, string type, Guid agentId, MessageLog message) Parameters Type Name Description String agent Name of the agent. String type The type of the interaction. Guid agentId The agent id. MessageLog message The message formatted as a MessageLog Properties | Improve this Doc View Source Agent Get the name of the agent. Declaration public string Agent { get; } Property Value Type Description String | Improve this Doc View Source AgentId Get the id of the agent. Declaration public Guid AgentId { get; } Property Value Type Description Guid Remarks Only relevant to find out if there are more than one instance of a specific agent. | Improve this Doc View Source Message Get the message, formatted as MessageLog . Declaration public MessageLog Message { get; } Property Value Type Description MessageLog | Improve this Doc View Source Type Get the type o the interaction Declaration public string Type { get; } Property Value Type Description String Remarks Currently these are \"Executing\", \"Executed\", \"Intercepting\" and \"Publishing\""
  },
  "api/Agents.Net.ConsumesAttribute.html": {
    "href": "api/Agents.Net.ConsumesAttribute.html",
    "title": "Class ConsumesAttribute | Agents.Net Documentation",
    "keywords": "Class ConsumesAttribute This attribute declares which Message s are consumed by the Agent . Inheritance Object ConsumesAttribute Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public sealed class ConsumesAttribute : Attribute Remarks This attribute is only valid for Agent s. Constructors | Improve this Doc View Source ConsumesAttribute(Type) Initializes a new instance of the ConsumesAttribute class. Declaration public ConsumesAttribute(Type messageType) Parameters Type Name Description Type messageType The type the the Message that is consumed by the Agent . Properties | Improve this Doc View Source Implicitly Gets or sets the Boolean value indicating whether the MessageType is consumed explicitly or implicitly. The default value is false . Declaration public bool Implicitly { get; set; } Property Value Type Description Boolean true if the MessageType is consumed implicitly; otherwise false . Remarks Consuming the message implicitly means, that the Execute(Message) method is not called for this MessageType . The Message is retrieved and used otherwise. If this property is set to false it has no effect on the execution, but serves as documentation. | Improve this Doc View Source MessageType Gets the type of Message that is consumed by the Agent . Declaration public Type MessageType { get; } Property Value Type Description Type"
  },
  "api/Agents.Net.DelayTokenReleaseIntention.html": {
    "href": "api/Agents.Net.DelayTokenReleaseIntention.html",
    "title": "Enum DelayTokenReleaseIntention | Agents.Net Documentation",
    "keywords": "Enum DelayTokenReleaseIntention The intention for the Release(DelayTokenReleaseIntention) method. Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public enum DelayTokenReleaseIntention : int Fields Name Description DoNotPublish Do not publish the delayed message Publish Publish the delayed message"
  },
  "api/Agents.Net.ExceptionMessage.html": {
    "href": "api/Agents.Net.ExceptionMessage.html",
    "title": "Class ExceptionMessage | Agents.Net Documentation",
    "keywords": "Class ExceptionMessage This message is send whenever there is an exception during the execution of an Agent . Inheritance Object Message ExceptionMessage Implements IDisposable Inherited Members Message.Id Message.ReplaceWith(Message) Message.SetChild(Message) Message.Is<T>() Message.Get<T>() Message.TryGet<T>(T) Message.MessageDomain Message.ToString() Message.Equals(Message) Message.Equals(Object) Message.GetHashCode() Message.DelayDispose() Message.Dispose(Boolean) Message.Dispose() Message.ToMessageLog() Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class ExceptionMessage : Message, IDisposable Remarks When there is a known error state in an Agent it should send the exception message directly because it is faster than throwing an exception and catching it again. No one will handle these messages by default. That means, that the program will continue to be executed even after an exception occured. In order to change that behavior an Agent must be defined which handles these messages and decides when to stop the program. For that exceptions are captured with their respective . With that the exception can be recreated together with the stacktrace by calling . Constructors | Improve this Doc View Source ExceptionMessage(ExceptionDispatchInfo, Message, Agent) Initialized a new instance of the class ExceptionMessage with a captured exception. Declaration public ExceptionMessage(ExceptionDispatchInfo exceptionInfo, Message message, Agent agent) Parameters Type Name Description ExceptionDispatchInfo exceptionInfo The captured exception info. Message message The predecessor message. Agent agent The agent that produced the exception. | Improve this Doc View Source ExceptionMessage(ExceptionDispatchInfo, IEnumerable<Message>, Agent) Initialized a new instance of the class ExceptionMessage with a captured exception. Declaration public ExceptionMessage(ExceptionDispatchInfo exceptionInfo, IEnumerable<Message> messages, Agent agent) Parameters Type Name Description ExceptionDispatchInfo exceptionInfo The captured exception info. IEnumerable < Message > messages The predecessor messages. Agent agent The agent that produced the exception. | Improve this Doc View Source ExceptionMessage(String, Message, Agent) Initialized a new instance of the class ExceptionMessage with a custom message. Declaration public ExceptionMessage(string customMessage, Message message, Agent agent) Parameters Type Name Description String customMessage The custom exception text. Message message The predecessor message. Agent agent The agent that produced the exception. | Improve this Doc View Source ExceptionMessage(String, IEnumerable<Message>, Agent) Initialized a new instance of the class ExceptionMessage with a custom message. Declaration public ExceptionMessage(string customMessage, IEnumerable<Message> messages, Agent agent) Parameters Type Name Description String customMessage The custom exception text. IEnumerable < Message > messages The predecessor messages. Agent agent The agent that produced the exception. Properties | Improve this Doc View Source Agent The agent which produced the exception. Declaration public Agent Agent { get; } Property Value Type Description Agent | Improve this Doc View Source CustomMessage Get the custom exception message. Declaration public string CustomMessage { get; } Property Value Type Description String Remarks When an exception is captured, this value is null . | Improve this Doc View Source ExceptionInfo Get the captured . Declaration public ExceptionDispatchInfo ExceptionInfo { get; } Property Value Type Description ExceptionDispatchInfo Remarks With that the exception can be recreated together with the stacktrace by calling . It can be null , when the CustomMessage is used instead. Methods | Improve this Doc View Source DataToString() Overridden data method. Declaration protected override string DataToString() Returns Type Description String Overrides Message.DataToString() Remarks This is not used as exception messages are locked differently than normal messages. Implements IDisposable"
  },
  "api/Agents.Net.html": {
    "href": "api/Agents.Net.html",
    "title": "Namespace Agents.Net | Agents.Net Documentation",
    "keywords": "Namespace Agents.Net Classes Agent Base class for all agents. It is necessary to inherit this base class in order to receive messages from the IMessageBoard . AgentLog This class is used to log an agent interaction in JSON format. ConsumesAttribute This attribute declares which Message s are consumed by the Agent . ExceptionMessage This message is send whenever there is an exception during the execution of an Agent . InitializeMessage The first message in the lifetime of a IMessageBoard . It is produced the by the IMessageBoard when the Start() method is called. InterceptionAction The action that should be taken with the message that was intercepted. InterceptionDelayToken The delay token to release a message that was delayed with the Delay(out InterceptionDelayToken) result. InterceptorAgent Base class for all agents that want to intercept a message. InterceptsAttribute This attribute declares which Message s are intercepted by the InterceptorAgent . Message Base class for all messages that are executed by the agents. MessageAggregationResult<TEnd> The result of the method. MessageAggregator<T> This class is deprecated. Please use MessageGate<TStart, TEnd> instead. MessageBoard This implementation implements the IMessageBoard interface for in-process agents. MessageCollection A collection of messages. MessageCollection<T1, T2> A collection of messages. MessageCollection<T1, T2, T3> A collection of messages. MessageCollection<T1, T2, T3, T4> A collection of messages. MessageCollection<T1, T2, T3, T4, T5> A collection of messages. MessageCollection<T1, T2, T3, T4, T5, T6> A collection of messages. MessageCollection<T1, T2, T3, T4, T5, T6, T7> A collection of messages. MessageCollector<T1, T2> This is a helper class that collects thread safe all messages until all message types are collected. MessageCollector<T1, T2, T3> This is a helper class that collects thread safe all messages until all message types are collected. MessageCollector<T1, T2, T3, T4> This is a helper class that collects thread safe all messages until all message types are collected. MessageCollector<T1, T2, T3, T4, T5> This is a helper class that collects thread safe all messages until all message types are collected. MessageCollector<T1, T2, T3, T4, T5, T6> This is a helper class that collects thread safe all messages until all message types are collected. MessageCollector<T1, T2, T3, T4, T5, T6, T7> This is a helper class that collects thread safe all messages until all message types are collected. MessageDecorator The base class for message decorators. MessageDomain The time domain the message is operating in. MessageGate<TStart, TEnd> This is a helper class which allows to collect a message pair consisting of a start and an end message. MessageGateResult<TEnd> The result of the SendAndAwait(TStart, Action<Message>, Int32, CancellationToken) method. MessageLog This class is used to log a message in JSON format. MessagesAggregated<T> This is the message that will be send automatically by the SendAndAggregate(IReadOnlyCollection<TStart>, Action<Message>) method. MessageStore<T> A wrapper class for a message that automatically uses DelayDispose() to delay the message disposal until this store is disposed. ProducesAttribute This attribute declares which Message s are produced by the Agent . Interfaces IMessageBoard General interface for all communication boards. Enums DelayTokenReleaseIntention The intention for the Release(DelayTokenReleaseIntention) method. MessageGateResultKind The result kind of the SendAndAwait(TStart, Action<Message>, Int32, CancellationToken) method."
  },
  "api/Agents.Net.IMessageBoard.html": {
    "href": "api/Agents.Net.IMessageBoard.html",
    "title": "Interface IMessageBoard | Agents.Net Documentation",
    "keywords": "Interface IMessageBoard General interface for all communication boards. Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public interface IMessageBoard Remarks The communication boards are responsible for sending the messages to all registered agents. Methods | Improve this Doc View Source Publish(Message) Publish the specific message to all consuming and intercepting agents. Declaration void Publish(Message message) Parameters Type Name Description Message message The message to publish. | Improve this Doc View Source Register(Agent[]) Register the agents to the message board. Declaration void Register(params Agent[] agents) Parameters Type Name Description Agent [] agents Agents to register. Remarks Agent s as well as InterceptorAgent s are registered with this method. It can be used after the Start() method, but this should be avoided, as the newly registered agent will not get any messages of the past. | Improve this Doc View Source Start() Start the message board. Declaration void Start() Remarks Without executing this method, no message will be passed the any agent. When it is executed it will automatically send an InitializeMessage ."
  },
  "api/Agents.Net.InitializeMessage.html": {
    "href": "api/Agents.Net.InitializeMessage.html",
    "title": "Class InitializeMessage | Agents.Net Documentation",
    "keywords": "Class InitializeMessage The first message in the lifetime of a IMessageBoard . It is produced the by the IMessageBoard when the Start() method is called. Inheritance Object Message InitializeMessage Implements IDisposable Inherited Members Message.Id Message.ReplaceWith(Message) Message.SetChild(Message) Message.Is<T>() Message.Get<T>() Message.TryGet<T>(T) Message.MessageDomain Message.ToString() Message.Equals(Message) Message.Equals(Object) Message.GetHashCode() Message.DelayDispose() Message.Dispose(Boolean) Message.Dispose() Message.ToMessageLog() Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class InitializeMessage : Message, IDisposable Constructors | Improve this Doc View Source InitializeMessage() Initialized a new instance of the class InitializeMessage . Declaration public InitializeMessage() Remarks This message does not have any predecessor message, therefore None can be given here. Methods | Improve this Doc View Source DataToString() Overridden data method. Declaration protected override string DataToString() Returns Type Description String Overrides Message.DataToString() Implements IDisposable"
  },
  "api/Agents.Net.InterceptionAction.html": {
    "href": "api/Agents.Net.InterceptionAction.html",
    "title": "Class InterceptionAction | Agents.Net Documentation",
    "keywords": "Class InterceptionAction The action that should be taken with the message that was intercepted. Inheritance Object InterceptionAction Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class InterceptionAction : object Properties | Improve this Doc View Source Continue Publish the message to all consuming agents. Declaration public static InterceptionAction Continue { get; } Property Value Type Description InterceptionAction | Improve this Doc View Source DoNotPublish Do not publish the message. If at least one InterceptorAgent returns this action, the message will not be published. Declaration public static InterceptionAction DoNotPublish { get; } Property Value Type Description InterceptionAction Remarks This action cannot be mixed with the DoNotPublish action. This will lead to an exception message. Methods | Improve this Doc View Source Delay(out InterceptionDelayToken) Delay the message. If at least one InterceptorAgent returns this action, the message will be published only after all InterceptionDelayToken s are released. Declaration public static InterceptionAction Delay(out InterceptionDelayToken delayToken) Parameters Type Name Description InterceptionDelayToken delayToken The delay token with which to release the message for sending. Returns Type Description InterceptionAction Remarks This action cannot be mixed with the DoNotPublish action. This will lead to an exception message."
  },
  "api/Agents.Net.InterceptionDelayToken.html": {
    "href": "api/Agents.Net.InterceptionDelayToken.html",
    "title": "Class InterceptionDelayToken | Agents.Net Documentation",
    "keywords": "Class InterceptionDelayToken The delay token to release a message that was delayed with the Delay(out InterceptionDelayToken) result. Inheritance Object InterceptionDelayToken Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class InterceptionDelayToken : object Methods | Improve this Doc View Source Release(DelayTokenReleaseIntention) Release the message. After this the intercepted message will be send. Declaration public void Release(DelayTokenReleaseIntention intention = DelayTokenReleaseIntention.Publish) Parameters Type Name Description DelayTokenReleaseIntention intention Indicates whether to publish the delayed message or not. Remarks If at least one InterceptionDelayToken returns the intention DoNotPublish the delayed message is not published."
  },
  "api/Agents.Net.InterceptorAgent.html": {
    "href": "api/Agents.Net.InterceptorAgent.html",
    "title": "Class InterceptorAgent | Agents.Net Documentation",
    "keywords": "Class InterceptorAgent Base class for all agents that want to intercept a message. Inheritance Object Agent InterceptorAgent Inherited Members Agent.Id Agent.Execute(Message) Agent.OnMessage(Message) Agent.OnMessages(IReadOnlyCollection<Message>) Agent.AddDisposable(IDisposable) Agent.Dispose(Boolean) Agent.Dispose() Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public abstract class InterceptorAgent : Agent Remarks Intercepting a message means, that it gets the message before any agent that is consuming the message. It can than do anything with that message - changing it, replacing it, decorating it, ... At the end the interceptor decides whether to publish the intercepted message or not. Examples [Intercepts(typeof(InterceptedMessage))] [Consumes(typeof(ConsumedMessage))] [Produces(typeof(ProducedMessage))] public class AgentImplementation : Agent { //Implementation } Constructors | Improve this Doc View Source InterceptorAgent(IMessageBoard, String) Initialized a new instance of the class InterceptorAgent . Declaration protected InterceptorAgent(IMessageBoard messageBoard, string name = null) Parameters Type Name Description IMessageBoard messageBoard The message board to send messages to. String name Optional name of the agent. The default is the name of the type. Remarks The name is only used for logging purposes. Methods | Improve this Doc View Source ExecuteCore(Message) The method which should be overridden by the implementation of the agent. It accepts the messages in the same way the Execute(Message) method does. Declaration protected override void ExecuteCore(Message messageData) Parameters Type Name Description Message messageData The received message. Overrides Agent.ExecuteCore(Message) | Improve this Doc View Source Intercept(Message) This method is called by the message boards to intercept a certain message. Declaration public InterceptionAction Intercept(Message messageData) Parameters Type Name Description Message messageData The message that is intercepted. Returns Type Description InterceptionAction The InterceptionAction , which defines whether the original message is published or not. Remarks Only messages which are defined with the InterceptsAttribute are passed to this method. Only the IMessageBoard should call this. It can also be used in unit tests. This method executes the InterceptCore(Message) method with the provided message. Additionally it logs all received messages and throw an exception method if the InterceptCore(Message) method throws an exception. | Improve this Doc View Source InterceptCore(Message) The method which should be overridden by the implementation of the agent. It accepts the messages in the same way the Intercept(Message) method does. Declaration protected abstract InterceptionAction InterceptCore(Message messageData) Parameters Type Name Description Message messageData The received message. Returns Type Description InterceptionAction The InterceptionAction , which defines whether the original message is published or not."
  },
  "api/Agents.Net.InterceptsAttribute.html": {
    "href": "api/Agents.Net.InterceptsAttribute.html",
    "title": "Class InterceptsAttribute | Agents.Net Documentation",
    "keywords": "Class InterceptsAttribute This attribute declares which Message s are intercepted by the InterceptorAgent . Inheritance Object InterceptsAttribute Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public sealed class InterceptsAttribute : Attribute Remarks This attribute is only valid for InterceptorAgent classes. Constructors | Improve this Doc View Source InterceptsAttribute(Type) Initializes a new instance of the InterceptsAttribute class. Declaration public InterceptsAttribute(Type messageType) Parameters Type Name Description Type messageType The type the the Message that is intercepted by the InterceptorAgent . Properties | Improve this Doc View Source MessageType Gets the type of Message that is intercepted by the InterceptorAgent . Declaration public Type MessageType { get; } Property Value Type Description Type"
  },
  "api/Agents.Net.Message.html": {
    "href": "api/Agents.Net.Message.html",
    "title": "Class Message | Agents.Net Documentation",
    "keywords": "Class Message Base class for all messages that are executed by the agents. Inheritance Object Message ExceptionMessage InitializeMessage MessageDecorator MessagesAggregated<T> Implements IDisposable Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public abstract class Message : IEquatable<Message>, IDisposable Remarks Each message knows its predecessors. Predecessors are the messages, that led to this message. Self disposing: The message is self disposing. The message board sets the number of uses of the message equal to the number of consuming agents. Whenever an agent executed the message the Agent base class marks the message as used. Once the message is completely used up it calls the Dispose() method. The message containers MessageCollector<T1, T2> and MessageAggregator<T> do delay the disposal until the container is executed. Currently there is a memory leak because the predecessors are strongly referenced. Therefore all messages produced by the system are kept in memory. See https://github.com/agents-net/agents.net/issues/75 for more information and timeline. Constructors | Improve this Doc View Source Message(Message) Initializes a new instances of this class with a single predecessor message. Declaration protected Message(Message predecessorMessage) Parameters Type Name Description Message predecessorMessage The predecessor message that led to this message. | Improve this Doc View Source Message(IEnumerable<Message>) Initializes a new instances of this class with multiple predecessor messages. Declaration protected Message(IEnumerable<Message> predecessorMessages) Parameters Type Name Description IEnumerable < Message > predecessorMessages The predecessor messages that led to this message. Properties | Improve this Doc View Source Id The id of the agent. Declaration public Guid Id { get; } Property Value Type Description Guid Remarks The id is only used for logging. | Improve this Doc View Source MessageDomain The message domain in which the message was created. Declaration public MessageDomain MessageDomain { get; } Property Value Type Description MessageDomain Remarks For more information about message domains see MessageDomain . Methods | Improve this Doc View Source DataToString() The method which should be overriden to provide a string representation of the carried data. Declaration protected abstract string DataToString() Returns Type Description String The string representation. Remarks If used, it should provide a short string as it is logged multiple times. To much data would slow down the application. | Improve this Doc View Source DelayDispose() This delays the self disposal of the message until the returned object is disposed. Declaration public IDisposable DelayDispose() Returns Type Description IDisposable The object which will release the message on dispose. Remarks This method should only be used, if there is a custom message container that stores this message. This regards the self disposing mechanism of the message. See the description for the type Message . | Improve this Doc View Source Dispose() Declaration public void Dispose() | Improve this Doc View Source Dispose(Boolean) Dispose any resources that are stored in the message. Declaration protected virtual void Dispose(bool disposing) Parameters Type Name Description Boolean disposing If true it was called from the Dispose() method. | Improve this Doc View Source Equals(Message) Declaration public bool Equals(Message other) Parameters Type Name Description Message other Returns Type Description Boolean | Improve this Doc View Source Equals(Object) Declaration public override bool Equals(object obj) Parameters Type Name Description Object obj Returns Type Description Boolean | Improve this Doc View Source Get<T>() Looks for the specified message type and returns it. Declaration public T Get<T>() where T : Message Returns Type Description T The message of the specified type or null if it was not found. Type Parameters Name Description T The message type that needs to be searched. Remarks This method is necessary because there can be a hierarchy of messages. In this case the whole stack needs to be searched for the message. Examples protected override void ExecuteCore(Message messageData) { //This will not work if the message is decorated SpecificMessage message = (SpecificMessage)messageData; //This will work either way SpecificMessage message = messageData.Get<SpecificMessage>(); } | Improve this Doc View Source GetHashCode() Declaration public override int GetHashCode() Returns Type Description Int32 | Improve this Doc View Source Is<T>() Checks whether this message is the specified type. Declaration public bool Is<T>() where T : Message Returns Type Description Boolean true , if this message is of the specified type. Type Parameters Name Description T The message type that needs to be searched. Remarks This method is necessary because there can be a hierarchy of messages. In this case the whole stack needs to be searched for the message. | Improve this Doc View Source ReplaceWith(Message) Replace this message with the given message. Declaration public void ReplaceWith(Message message) Parameters Type Name Description Message message The message which replaces this message. Remarks This method is intended of the use case, that an InterceptorAgent wants to replace a, message with a different message. How to do this see the example. Examples This example shows the use case how to replace a message using an InterceptorAgent protected override InterceptionAction InterceptCore(Message messageData) { Message replacingMessage = GenerateNewMessage(); messageData.ReplaceWith(replacingMessage); OnMessage(replacingMessage); return InterceptionAction.DoNotPublish; } | Improve this Doc View Source SetChild(Message) this is an internal method used by the MessageDecorator . It should not be used outside of that. Declaration protected void SetChild(Message childMessage) Parameters Type Name Description Message childMessage The new child message. | Improve this Doc View Source ToMessageLog() This is used to log the message. It creates the serializable class MessageLog . Declaration public MessageLog ToMessageLog() Returns Type Description MessageLog The MessageLog instance. Remarks This method is mostly used internally. | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description String | Improve this Doc View Source TryGet<T>(out T) Tries to looks for the specified message type and returns it. Declaration public bool TryGet<T>(out T result) where T : Message Parameters Type Name Description T result The message of the specified type. Returns Type Description Boolean true , if the message was found; otherwise false . Type Parameters Name Description T The message type that needs to be searched. Remarks This method is necessary because there can be a hierarchy of messages. In this case the whole stack needs to be searched for the message. Examples protected override void ExecuteCore(Message messageData) { //This will not execute if the message was decorated if(messageData is SpecificMessage message) { //... } //This will work either way if(messageData.TryGet(out SpecificMessage message)) { //... } } Operators | Improve this Doc View Source Equality(Message, Message) Determines whether both messages are equal or not. Declaration public static bool operator ==(Message left, Message right) Parameters Type Name Description Message left The left message Message right The right message Returns Type Description Boolean true , if both messages are equal; otherwise false . | Improve this Doc View Source Inequality(Message, Message) Determines whether both messages are not equal or not. Declaration public static bool operator !=(Message left, Message right) Parameters Type Name Description Message left The left message Message right The right message Returns Type Description Boolean true , if both messages are not equal; otherwise false . Implements IDisposable"
  },
  "api/Agents.Net.MessageAggregationResult-1.html": {
    "href": "api/Agents.Net.MessageAggregationResult-1.html",
    "title": "Class MessageAggregationResult<TEnd> | Agents.Net Documentation",
    "keywords": "Class MessageAggregationResult<TEnd> The result of the method. Inheritance Object MessageAggregationResult<TEnd> Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class MessageAggregationResult<TEnd> : object where TEnd : Message Type Parameters Name Description TEnd Constructors | Improve this Doc View Source MessageAggregationResult(MessageGateResultKind, IReadOnlyCollection<TEnd>, IReadOnlyCollection<ExceptionMessage>) Instantiate a new instance of MessageAggregationResult<TEnd> . Declaration public MessageAggregationResult(MessageGateResultKind result, IReadOnlyCollection<TEnd> endMessages, IReadOnlyCollection<ExceptionMessage> exceptions) Parameters Type Name Description MessageGateResultKind result The aggregation result. IReadOnlyCollection <TEnd> endMessages The final messages. IReadOnlyCollection < ExceptionMessage > exceptions Exceptions during execution. Properties | Improve this Doc View Source EndMessages The final messages. Declaration public IReadOnlyCollection<TEnd> EndMessages { get; } Property Value Type Description IReadOnlyCollection <TEnd> | Improve this Doc View Source Exceptions The exception messages that were recorded. Declaration public IReadOnlyCollection<ExceptionMessage> Exceptions { get; } Property Value Type Description IReadOnlyCollection < ExceptionMessage > | Improve this Doc View Source Result The result of the aggregation. Declaration public MessageGateResultKind Result { get; } Property Value Type Description MessageGateResultKind Methods | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description String"
  },
  "api/Agents.Net.MessageAggregator-1.html": {
    "href": "api/Agents.Net.MessageAggregator-1.html",
    "title": "Class MessageAggregator<T> | Agents.Net Documentation",
    "keywords": "Class MessageAggregator<T> This class is deprecated. Please use MessageGate<TStart, TEnd> instead. Inheritance Object MessageAggregator<T> Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class MessageAggregator<T> : object where T : Message Type Parameters Name Description T The type of the message which should be aggregated. Remarks When a batch of messages is published using the OnMessages(IReadOnlyCollection<Message>) they can be united again when all last messages of the execution chain are of the same type. -------------- --------------------- ----------------- | SplitMessage | ----> | IntermediateMessage | -----> | FinishedMessage | -------------- --------------------- | ----------------- | | ------------------ ----> | ExceptionMessage | ------------------ Looking at the example above it would not be possible to unite the SplitMessages again using this class as at least one IntermediateMessage let to an ExceptionMessage . Here a typical example how to setup and use the aggregator in a class: [Consumes(typeof(FinishedMessage))] public class MessageAggregatorAgent : Agent { private readonly MessageAggregator<FinishedMessage> aggregator; public MessageAggregatorAgent(IMessageBoard messageBoard) : base(messageBoard) { aggregator = new MessageAggregator&lt;FinishedMessage>(OnAggregated); } private void OnAggregated(IReadOnlyCollection&lt;FinishedMessage> aggregate) { //Execute your code here } protected override void ExecuteCore(Message messageData) { aggregator.Aggregate(messageData); } } Constructors | Improve this Doc View Source MessageAggregator(Action<IReadOnlyCollection<T>>, Boolean) Initialized a new instance of the class MessageAggregator<T> . Declaration public MessageAggregator(Action<IReadOnlyCollection<T>> onAggregated, bool autoTerminate = true) Parameters Type Name Description Action < IReadOnlyCollection <T>> onAggregated The action which is executed when all messages were aggregated. Boolean autoTerminate If set to true , the aggregator will terminate all message domains of the aggregated messages before the execution. Default is true . Methods | Improve this Doc View Source Aggregate(Message) Adds the message to this instance. Declaration public void Aggregate(Message message) Parameters Type Name Description Message message The message to add to this instance. | Improve this Doc View Source TryAggregate(Message) Tries to add the message to this instance. Declaration public bool TryAggregate(Message message) Parameters Type Name Description Message message The message to add to this instance. Returns Type Description Boolean true if the message was added; otherwise false Remarks This is useful, when the Agent consumes more than the aggregated message."
  },
  "api/Agents.Net.MessageBoard.html": {
    "href": "api/Agents.Net.MessageBoard.html",
    "title": "Class MessageBoard | Agents.Net Documentation",
    "keywords": "Class MessageBoard This implementation implements the IMessageBoard interface for in-process agents. Inheritance Object MessageBoard Implements IMessageBoard Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public sealed class MessageBoard : IDisposable, IMessageBoard Remarks This implementation guaranties the following qualities: parallelAll agents are executed parallel. Methods | Improve this Doc View Source Dispose() Declaration public void Dispose() | Improve this Doc View Source Publish(Message) Publish the specific message to all consuming and intercepting agents. Declaration public void Publish(Message message) Parameters Type Name Description Message message The message to publish. | Improve this Doc View Source Register(Agent[]) Register the agents to the message board. Declaration public void Register(params Agent[] agents) Parameters Type Name Description Agent [] agents Agents to register. Remarks Agent s as well as InterceptorAgent s are registered with this method. It can be used after the Start() method, but this should be avoided, as the newly registered agent will not get any messages of the past. | Improve this Doc View Source Start() Start the message board. Declaration public void Start() Remarks Without executing this method, no message will be passed the any agent. When it is executed it will automatically send an InitializeMessage . Implements IMessageBoard"
  },
  "api/Agents.Net.MessageCollection.html": {
    "href": "api/Agents.Net.MessageCollection.html",
    "title": "Class MessageCollection | Agents.Net Documentation",
    "keywords": "Class MessageCollection A collection of messages. Inheritance Object MessageCollection MessageCollection<T1, T2> Implements IDisposable Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public abstract class MessageCollection : IEnumerable<Message>, IDisposable Remarks This is a helper class for the MessageCollector<T1, T2> Methods | Improve this Doc View Source Dispose() Declaration public void Dispose() | Improve this Doc View Source Dispose(Boolean) Disposes all MessageStore<T> s contained in this collection Declaration protected abstract void Dispose(bool disposing) Parameters Type Name Description Boolean disposing Remarks This releases the usage of the message and therefore potentially disposes the contained Message . When a message is used more than once in the MessageCollector<T1, T2> , the Agent that contains the MessageCollector<T1, T2> should mark the message with DelayDispose() . | Improve this Doc View Source GetAllMessages() When overridden needs to return all messages in the collection. Declaration protected virtual IEnumerable<Message> GetAllMessages() Returns Type Description IEnumerable < Message > | Improve this Doc View Source GetEnumerator() Declaration public IEnumerator<Message> GetEnumerator() Returns Type Description IEnumerator < Message > | Improve this Doc View Source MarkAsConsumed(Message) Mark the specified message as consumed. Declaration public abstract void MarkAsConsumed(Message message) Parameters Type Name Description Message message The message that will be marked. Remarks The usual behavior for the MessageCollector<T1, T2> is to retain all messages that were collected, until other message of the same type replaces the the old message. This method changes that behavior, so that the marked message is removed from the collector afterwards. Implements IDisposable"
  },
  "api/Agents.Net.MessageCollection-2.html": {
    "href": "api/Agents.Net.MessageCollection-2.html",
    "title": "Class MessageCollection<T1, T2> | Agents.Net Documentation",
    "keywords": "Class MessageCollection<T1, T2> A collection of messages. Inheritance Object MessageCollection MessageCollection<T1, T2> MessageCollection<T1, T2, T3> Implements IDisposable Inherited Members MessageCollection.GetEnumerator() MessageCollection.Dispose() Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class MessageCollection<T1, T2> : MessageCollection, IDisposable where T1 : Message where T2 : Message Type Parameters Name Description T1 T2 Remarks This is a helper class for the MessageCollector<T1, T2> Constructors | Improve this Doc View Source MessageCollection(MessageStore<T1>, MessageStore<T2>, MessageCollector<T1, T2>) Initialized a new instance of the class MessageCollection<T1, T2> . Declaration public MessageCollection(MessageStore<T1> message1, MessageStore<T2> message2, MessageCollector<T1, T2> collector) Parameters Type Name Description MessageStore <T1> message1 Message of type T1 . MessageStore <T2> message2 Message of type T2 . MessageCollector <T1, T2> collector The MessageCollector<T1, T2> that produced this instance. Properties | Improve this Doc View Source Message1 Message of type T1 . Declaration public T1 Message1 { get; } Property Value Type Description T1 | Improve this Doc View Source Message2 Message of type T2 . Declaration public T2 Message2 { get; } Property Value Type Description T2 Methods | Improve this Doc View Source Dispose(Boolean) Disposes all MessageStore<T> s contained in this collection Declaration protected override void Dispose(bool disposing) Parameters Type Name Description Boolean disposing Overrides MessageCollection.Dispose(Boolean) Remarks This releases the usage of the message and therefore potentially disposes the contained Message . When a message is used more than once in the MessageCollector<T1, T2> , the Agent that contains the MessageCollector<T1, T2> should mark the message with DelayDispose() . | Improve this Doc View Source GetAllMessages() When overridden needs to return all messages in the collection. Declaration protected override IEnumerable<Message> GetAllMessages() Returns Type Description IEnumerable < Message > Overrides MessageCollection.GetAllMessages() | Improve this Doc View Source MarkAsConsumed(Message) Mark the specified message as consumed. Declaration public override void MarkAsConsumed(Message message) Parameters Type Name Description Message message The message that will be marked. Overrides MessageCollection.MarkAsConsumed(Message) Remarks The usual behavior for the MessageCollector<T1, T2> is to retain all messages that were collected, until other message of the same type replaces the the old message. This method changes that behavior, so that the marked message is removed from the collector afterwards. Implements IDisposable"
  },
  "api/Agents.Net.MessageCollection-3.html": {
    "href": "api/Agents.Net.MessageCollection-3.html",
    "title": "Class MessageCollection<T1, T2, T3> | Agents.Net Documentation",
    "keywords": "Class MessageCollection<T1, T2, T3> A collection of messages. Inheritance Object MessageCollection MessageCollection <T1, T2> MessageCollection<T1, T2, T3> MessageCollection<T1, T2, T3, T4> Implements IDisposable Inherited Members MessageCollection<T1, T2>.Message1 MessageCollection<T1, T2>.Message2 MessageCollection<T1, T2>.GetAllMessages() MessageCollection<T1, T2>.MarkAsConsumed(Message) MessageCollection<T1, T2>.Dispose(Boolean) MessageCollection.GetEnumerator() MessageCollection.MarkAsConsumed(Message) MessageCollection.Dispose() Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class MessageCollection<T1, T2, T3> : MessageCollection<T1, T2>, IDisposable where T1 : Message where T2 : Message where T3 : Message Type Parameters Name Description T1 T2 T3 Remarks This is a helper class for the MessageCollector<T1, T2> Constructors | Improve this Doc View Source MessageCollection(MessageStore<T1>, MessageStore<T2>, MessageStore<T3>, MessageCollector<T1, T2>) Initialized a new instance of the class MessageCollection<T1, T2, T3> . Declaration public MessageCollection(MessageStore<T1> message1, MessageStore<T2> message2, MessageStore<T3> message3, MessageCollector<T1, T2> collector) Parameters Type Name Description MessageStore <T1> message1 Message of type T1 . MessageStore <T2> message2 Message of type T2 . MessageStore <T3> message3 Message of type T3 . MessageCollector <T1, T2> collector The MessageCollector<T1, T2> that produced this instance. Properties | Improve this Doc View Source Message3 Message of type T3 . Declaration public T3 Message3 { get; } Property Value Type Description T3 Methods | Improve this Doc View Source Dispose(Boolean) Disposes all MessageStore<T> s contained in this collection Declaration protected override void Dispose(bool disposing) Parameters Type Name Description Boolean disposing Overrides Agents.Net.MessageCollection<T1, T2>.Dispose(System.Boolean) Remarks This releases the usage of the message and therefore potentially disposes the contained Message . When a message is used more than once in the MessageCollector<T1, T2> , the Agent that contains the MessageCollector<T1, T2> should mark the message with DelayDispose() . | Improve this Doc View Source GetAllMessages() When overridden needs to return all messages in the collection. Declaration protected override IEnumerable<Message> GetAllMessages() Returns Type Description IEnumerable < Message > Overrides Agents.Net.MessageCollection<T1, T2>.GetAllMessages() Implements IDisposable"
  },
  "api/Agents.Net.MessageCollection-4.html": {
    "href": "api/Agents.Net.MessageCollection-4.html",
    "title": "Class MessageCollection<T1, T2, T3, T4> | Agents.Net Documentation",
    "keywords": "Class MessageCollection<T1, T2, T3, T4> A collection of messages. Inheritance Object MessageCollection MessageCollection <T1, T2> MessageCollection <T1, T2, T3> MessageCollection<T1, T2, T3, T4> MessageCollection<T1, T2, T3, T4, T5> Implements IDisposable Inherited Members MessageCollection<T1, T2, T3>.Message3 MessageCollection<T1, T2, T3>.GetAllMessages() MessageCollection<T1, T2, T3>.Dispose(Boolean) MessageCollection<T1, T2>.Message1 MessageCollection<T1, T2>.Message2 MessageCollection<T1, T2>.GetAllMessages() MessageCollection<T1, T2>.MarkAsConsumed(Message) MessageCollection<T1, T2>.Dispose(Boolean) MessageCollection.GetEnumerator() MessageCollection.MarkAsConsumed(Message) MessageCollection.Dispose() Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class MessageCollection<T1, T2, T3, T4> : MessageCollection<T1, T2, T3>, IDisposable where T1 : Message where T2 : Message where T3 : Message where T4 : Message Type Parameters Name Description T1 T2 T3 T4 Remarks This is a helper class for the MessageCollector<T1, T2> Constructors | Improve this Doc View Source MessageCollection(MessageStore<T1>, MessageStore<T2>, MessageStore<T3>, MessageStore<T4>, MessageCollector<T1, T2>) Initialized a new instance of the class MessageCollection<T1, T2, T3, T4> . Declaration public MessageCollection(MessageStore<T1> message1, MessageStore<T2> message2, MessageStore<T3> message3, MessageStore<T4> message4, MessageCollector<T1, T2> collector) Parameters Type Name Description MessageStore <T1> message1 Message of type T1 . MessageStore <T2> message2 Message of type T2 . MessageStore <T3> message3 Message of type T3 . MessageStore <T4> message4 Message of type T4 . MessageCollector <T1, T2> collector The MessageCollector<T1, T2> that produced this instance. Properties | Improve this Doc View Source Message4 Message of type T4 . Declaration public T4 Message4 { get; } Property Value Type Description T4 Methods | Improve this Doc View Source Dispose(Boolean) Disposes all MessageStore<T> s contained in this collection Declaration protected override void Dispose(bool disposing) Parameters Type Name Description Boolean disposing Overrides Agents.Net.MessageCollection<T1, T2, T3>.Dispose(System.Boolean) Remarks This releases the usage of the message and therefore potentially disposes the contained Message . When a message is used more than once in the MessageCollector<T1, T2> , the Agent that contains the MessageCollector<T1, T2> should mark the message with DelayDispose() . | Improve this Doc View Source GetAllMessages() When overridden needs to return all messages in the collection. Declaration protected override IEnumerable<Message> GetAllMessages() Returns Type Description IEnumerable < Message > Overrides Agents.Net.MessageCollection<T1, T2, T3>.GetAllMessages() Implements IDisposable"
  },
  "api/Agents.Net.MessageCollection-5.html": {
    "href": "api/Agents.Net.MessageCollection-5.html",
    "title": "Class MessageCollection<T1, T2, T3, T4, T5> | Agents.Net Documentation",
    "keywords": "Class MessageCollection<T1, T2, T3, T4, T5> A collection of messages. Inheritance Object MessageCollection MessageCollection <T1, T2> MessageCollection <T1, T2, T3> MessageCollection <T1, T2, T3, T4> MessageCollection<T1, T2, T3, T4, T5> MessageCollection<T1, T2, T3, T4, T5, T6> Implements IDisposable Inherited Members MessageCollection<T1, T2, T3, T4>.Message4 MessageCollection<T1, T2, T3, T4>.GetAllMessages() MessageCollection<T1, T2, T3, T4>.Dispose(Boolean) MessageCollection<T1, T2, T3>.Message3 MessageCollection<T1, T2, T3>.GetAllMessages() MessageCollection<T1, T2, T3>.Dispose(Boolean) MessageCollection<T1, T2>.Message1 MessageCollection<T1, T2>.Message2 MessageCollection<T1, T2>.GetAllMessages() MessageCollection<T1, T2>.MarkAsConsumed(Message) MessageCollection<T1, T2>.Dispose(Boolean) MessageCollection.GetEnumerator() MessageCollection.MarkAsConsumed(Message) MessageCollection.Dispose() Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class MessageCollection<T1, T2, T3, T4, T5> : MessageCollection<T1, T2, T3, T4>, IDisposable where T1 : Message where T2 : Message where T3 : Message where T4 : Message where T5 : Message Type Parameters Name Description T1 T2 T3 T4 T5 Remarks This is a helper class for the MessageCollector<T1, T2> Constructors | Improve this Doc View Source MessageCollection(MessageStore<T1>, MessageStore<T2>, MessageStore<T3>, MessageStore<T4>, MessageStore<T5>, MessageCollector<T1, T2>) Initialized a new instance of the class MessageCollection<T1, T2, T3, T4, T5> . Declaration public MessageCollection(MessageStore<T1> message1, MessageStore<T2> message2, MessageStore<T3> message3, MessageStore<T4> message4, MessageStore<T5> message5, MessageCollector<T1, T2> collector) Parameters Type Name Description MessageStore <T1> message1 Message of type T1 . MessageStore <T2> message2 Message of type T2 . MessageStore <T3> message3 Message of type T3 . MessageStore <T4> message4 Message of type T4 . MessageStore <T5> message5 Message of type T5 . MessageCollector <T1, T2> collector The MessageCollector<T1, T2> that produced this instance. Properties | Improve this Doc View Source Message5 Message of type T5 . Declaration public T5 Message5 { get; } Property Value Type Description T5 Methods | Improve this Doc View Source Dispose(Boolean) Disposes all MessageStore<T> s contained in this collection Declaration protected override void Dispose(bool disposing) Parameters Type Name Description Boolean disposing Overrides Agents.Net.MessageCollection<T1, T2, T3, T4>.Dispose(System.Boolean) Remarks This releases the usage of the message and therefore potentially disposes the contained Message . When a message is used more than once in the MessageCollector<T1, T2> , the Agent that contains the MessageCollector<T1, T2> should mark the message with DelayDispose() . | Improve this Doc View Source GetAllMessages() When overridden needs to return all messages in the collection. Declaration protected override IEnumerable<Message> GetAllMessages() Returns Type Description IEnumerable < Message > Overrides Agents.Net.MessageCollection<T1, T2, T3, T4>.GetAllMessages() Implements IDisposable"
  },
  "api/Agents.Net.MessageCollection-6.html": {
    "href": "api/Agents.Net.MessageCollection-6.html",
    "title": "Class MessageCollection<T1, T2, T3, T4, T5, T6> | Agents.Net Documentation",
    "keywords": "Class MessageCollection<T1, T2, T3, T4, T5, T6> A collection of messages. Inheritance Object MessageCollection MessageCollection <T1, T2> MessageCollection <T1, T2, T3> MessageCollection <T1, T2, T3, T4> MessageCollection <T1, T2, T3, T4, T5> MessageCollection<T1, T2, T3, T4, T5, T6> MessageCollection<T1, T2, T3, T4, T5, T6, T7> Implements IDisposable Inherited Members MessageCollection<T1, T2, T3, T4, T5>.Message5 MessageCollection<T1, T2, T3, T4, T5>.GetAllMessages() MessageCollection<T1, T2, T3, T4, T5>.Dispose(Boolean) MessageCollection<T1, T2, T3, T4>.Message4 MessageCollection<T1, T2, T3, T4>.GetAllMessages() MessageCollection<T1, T2, T3, T4>.Dispose(Boolean) MessageCollection<T1, T2, T3>.Message3 MessageCollection<T1, T2, T3>.GetAllMessages() MessageCollection<T1, T2, T3>.Dispose(Boolean) MessageCollection<T1, T2>.Message1 MessageCollection<T1, T2>.Message2 MessageCollection<T1, T2>.GetAllMessages() MessageCollection<T1, T2>.MarkAsConsumed(Message) MessageCollection<T1, T2>.Dispose(Boolean) MessageCollection.GetEnumerator() MessageCollection.MarkAsConsumed(Message) MessageCollection.Dispose() Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class MessageCollection<T1, T2, T3, T4, T5, T6> : MessageCollection<T1, T2, T3, T4, T5>, IDisposable where T1 : Message where T2 : Message where T3 : Message where T4 : Message where T5 : Message where T6 : Message Type Parameters Name Description T1 T2 T3 T4 T5 T6 Remarks This is a helper class for the MessageCollector<T1, T2> Constructors | Improve this Doc View Source MessageCollection(MessageStore<T1>, MessageStore<T2>, MessageStore<T3>, MessageStore<T4>, MessageStore<T5>, MessageStore<T6>, MessageCollector<T1, T2>) Initialized a new instance of the class MessageCollection<T1, T2, T3, T4, T5, T6> . Declaration public MessageCollection(MessageStore<T1> message1, MessageStore<T2> message2, MessageStore<T3> message3, MessageStore<T4> message4, MessageStore<T5> message5, MessageStore<T6> message6, MessageCollector<T1, T2> collector) Parameters Type Name Description MessageStore <T1> message1 Message of type T1 . MessageStore <T2> message2 Message of type T2 . MessageStore <T3> message3 Message of type T3 . MessageStore <T4> message4 Message of type T4 . MessageStore <T5> message5 Message of type T5 . MessageStore <T6> message6 Message of type T6 . MessageCollector <T1, T2> collector The MessageCollector<T1, T2> that produced this instance. Properties | Improve this Doc View Source Message6 Message of type T6 . Declaration public T6 Message6 { get; } Property Value Type Description T6 Methods | Improve this Doc View Source Dispose(Boolean) Disposes all MessageStore<T> s contained in this collection Declaration protected override void Dispose(bool disposing) Parameters Type Name Description Boolean disposing Overrides Agents.Net.MessageCollection<T1, T2, T3, T4, T5>.Dispose(System.Boolean) Remarks This releases the usage of the message and therefore potentially disposes the contained Message . When a message is used more than once in the MessageCollector<T1, T2> , the Agent that contains the MessageCollector<T1, T2> should mark the message with DelayDispose() . | Improve this Doc View Source GetAllMessages() When overridden needs to return all messages in the collection. Declaration protected override IEnumerable<Message> GetAllMessages() Returns Type Description IEnumerable < Message > Overrides Agents.Net.MessageCollection<T1, T2, T3, T4, T5>.GetAllMessages() Implements IDisposable"
  },
  "api/Agents.Net.MessageCollection-7.html": {
    "href": "api/Agents.Net.MessageCollection-7.html",
    "title": "Class MessageCollection<T1, T2, T3, T4, T5, T6, T7> | Agents.Net Documentation",
    "keywords": "Class MessageCollection<T1, T2, T3, T4, T5, T6, T7> A collection of messages. Inheritance Object MessageCollection MessageCollection <T1, T2> MessageCollection <T1, T2, T3> MessageCollection <T1, T2, T3, T4> MessageCollection <T1, T2, T3, T4, T5> MessageCollection <T1, T2, T3, T4, T5, T6> MessageCollection<T1, T2, T3, T4, T5, T6, T7> Implements IDisposable Inherited Members MessageCollection<T1, T2, T3, T4, T5, T6>.Message6 MessageCollection<T1, T2, T3, T4, T5, T6>.GetAllMessages() MessageCollection<T1, T2, T3, T4, T5, T6>.Dispose(Boolean) MessageCollection<T1, T2, T3, T4, T5>.Message5 MessageCollection<T1, T2, T3, T4, T5>.GetAllMessages() MessageCollection<T1, T2, T3, T4, T5>.Dispose(Boolean) MessageCollection<T1, T2, T3, T4>.Message4 MessageCollection<T1, T2, T3, T4>.GetAllMessages() MessageCollection<T1, T2, T3, T4>.Dispose(Boolean) MessageCollection<T1, T2, T3>.Message3 MessageCollection<T1, T2, T3>.GetAllMessages() MessageCollection<T1, T2, T3>.Dispose(Boolean) MessageCollection<T1, T2>.Message1 MessageCollection<T1, T2>.Message2 MessageCollection<T1, T2>.GetAllMessages() MessageCollection<T1, T2>.MarkAsConsumed(Message) MessageCollection<T1, T2>.Dispose(Boolean) MessageCollection.GetEnumerator() MessageCollection.MarkAsConsumed(Message) MessageCollection.Dispose() Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class MessageCollection<T1, T2, T3, T4, T5, T6, T7> : MessageCollection<T1, T2, T3, T4, T5, T6>, IDisposable where T1 : Message where T2 : Message where T3 : Message where T4 : Message where T5 : Message where T6 : Message where T7 : Message Type Parameters Name Description T1 T2 T3 T4 T5 T6 T7 Remarks This is a helper class for the MessageCollector<T1, T2> Constructors | Improve this Doc View Source MessageCollection(MessageStore<T1>, MessageStore<T2>, MessageStore<T3>, MessageStore<T4>, MessageStore<T5>, MessageStore<T6>, MessageStore<T7>, MessageCollector<T1, T2>) Initialized a new instance of the class MessageCollection<T1, T2, T3, T4, T5, T6, T7> . Declaration public MessageCollection(MessageStore<T1> message1, MessageStore<T2> message2, MessageStore<T3> message3, MessageStore<T4> message4, MessageStore<T5> message5, MessageStore<T6> message6, MessageStore<T7> message7, MessageCollector<T1, T2> collector) Parameters Type Name Description MessageStore <T1> message1 Message of type T1 . MessageStore <T2> message2 Message of type T2 . MessageStore <T3> message3 Message of type T3 . MessageStore <T4> message4 Message of type T4 . MessageStore <T5> message5 Message of type T5 . MessageStore <T6> message6 Message of type T6 . MessageStore <T7> message7 Message of type T7 . MessageCollector <T1, T2> collector The MessageCollector<T1, T2> that produced this instance. Properties | Improve this Doc View Source Message7 Message of type T7 . Declaration public T7 Message7 { get; } Property Value Type Description T7 Methods | Improve this Doc View Source Dispose(Boolean) Disposes all MessageStore<T> s contained in this collection Declaration protected override void Dispose(bool disposing) Parameters Type Name Description Boolean disposing Overrides Agents.Net.MessageCollection<T1, T2, T3, T4, T5, T6>.Dispose(System.Boolean) Remarks This releases the usage of the message and therefore potentially disposes the contained Message . When a message is used more than once in the MessageCollector<T1, T2> , the Agent that contains the MessageCollector<T1, T2> should mark the message with DelayDispose() . | Improve this Doc View Source GetAllMessages() When overridden needs to return all messages in the collection. Declaration protected override IEnumerable<Message> GetAllMessages() Returns Type Description IEnumerable < Message > Overrides Agents.Net.MessageCollection<T1, T2, T3, T4, T5, T6>.GetAllMessages() Implements IDisposable"
  },
  "api/Agents.Net.MessageCollector-2.html": {
    "href": "api/Agents.Net.MessageCollector-2.html",
    "title": "Class MessageCollector<T1, T2> | Agents.Net Documentation",
    "keywords": "Class MessageCollector<T1, T2> This is a helper class that collects thread safe all messages until all message types are collected. Inheritance Object MessageCollector<T1, T2> MessageCollector<T1, T2, T3> Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class MessageCollector<T1, T2> : object where T1 : Message where T2 : Message Type Parameters Name Description T1 First message type. T2 Second message type. Remarks The collector collects messages until all message types are collected. Afterwards it executes an action with the collected MessageCollection . In the following different scenarios are described, which explain the different aspects of this class. Overriding messages Assuming the message of type T1 was collected and T2 was not. When another message of type T1 is collected it replaces the old T1 message with the new message. No action is executed. Considering message domains Assuming the following MessageDomain s and the collected messages: --------------- ------------ | DefaultDomain | ----> | SubDomain1 | --------------- | ------------ T1 Message1 | T1 Message2 | T2 Message4 | | ------------ ----> | SubDomain2 | ------------ T2 Message3 T2 Message5 Here is what happens in this scenario. Message1 is collected. Message2 is collected. This does not override Message1 because it is from a different MessageDomain. It is stored parallel. Message3 is collected. Now SubDomain2 has a complete set of Message1 + Message3. Message 4 is collected. Now there is another completed set in SubDomain1 of Message2 + Message4. Message5 is collected. This overrides Message3 as it is in the same MessageDomain. A new set is executed with Message1 + Message5. In the end the following sets were executed inorder: Message1 + Message3 Message2 + Message4 Message1 + Message5 Consumed vs not consumed messages Messages can be consumed during execution with the method MarkAsConsumed(Message) . The consumed message is removed from the message collector immediately. Looking at the example above the Message1 is used twice. Assuming during the first execution of Message1 + Message3 the agent executed collection.MarkAsConsumed(Message1) . In this case the third execution Message1 + Message5 would not have happened, as Message1 would have been cleared from the collector instance. Examples Here a typical example how to setup and use the collector in a class: [Consumes(typeof(Message1))] [Consumes(typeof(Message2))] public class MessageCollectorAgent : Agent { private readonly MessageCollector<Message1, Message2> collector; public MessageCollectorAgent(IMessageBoard messageBoard) : base(messageBoard) { collector = new MessageCollector<Message1, Message2>(OnMessagesCollected); } private void OnMessagesCollected(MessageCollection<Message1, Message2> set) { //execute set } protected override void ExecuteCore(Message messageData) { collector.Push(messageData); } } Constructors | Improve this Doc View Source MessageCollector(Action<MessageCollection<T1, T2>>) Initialized a new instance of the class MessageCollector<T1, T2> . Declaration public MessageCollector(Action<MessageCollection<T1, T2>> onMessagesCollected = null) Parameters Type Name Description Action < MessageCollection <T1, T2>> onMessagesCollected The action which is executed when all messages were collected. Properties | Improve this Doc View Source Messages1 Store for messages of type T1 . Declaration protected Dictionary<MessageDomain, MessageStore<T1>> Messages1 { get; } Property Value Type Description Dictionary < MessageDomain , MessageStore <T1>> | Improve this Doc View Source Messages2 Store for messages of type T2 . Declaration protected Dictionary<MessageDomain, MessageStore<T2>> Messages2 { get; } Property Value Type Description Dictionary < MessageDomain , MessageStore <T2>> Methods | Improve this Doc View Source Aggregate(Message, Boolean) Overridden by inheriting classes to try to add the message to the collector dictionaries. Declaration protected virtual bool Aggregate(Message message, bool throwError) Parameters Type Name Description Message message The message to add Boolean throwError If set to true , throws an error if the message could not be added. Returns Type Description Boolean true if the message was added to any dictionary; otherwise false . | Improve this Doc View Source Execute(MessageCollection) Overridden by inheriting classes to execute the typeless message collection cast to the specific collector type.. Declaration protected virtual void Execute(MessageCollection messageCollection) Parameters Type Name Description MessageCollection messageCollection The typeless collection. | Improve this Doc View Source ExecutePushAndContinue(Message, Action<MessageCollection>, CancellationToken) Execute the routine for PushAndExecute(Message, Action<MessageCollection<T1, T2>>, CancellationToken) . Declaration protected void ExecutePushAndContinue(Message message, Action<MessageCollection> executeAction, CancellationToken cancellationToken) Parameters Type Name Description Message message The message which is pushed. Action < MessageCollection > executeAction The action which should execute the action which was passed to the PushAndExecute(Message, Action<MessageCollection<T1, T2>>, CancellationToken) method. CancellationToken cancellationToken | Improve this Doc View Source ExecutePushAndExecute(Message, Action<MessageCollection>, CancellationToken) Execute the routine for PushAndExecute(Message, Action<MessageCollection<T1, T2>>, CancellationToken) . Declaration protected bool ExecutePushAndExecute(Message message, Action<MessageCollection> executeAction, CancellationToken cancellationToken) Parameters Type Name Description Message message The message which is pushed. Action < MessageCollection > executeAction The action which should execute the action which was passed to the PushAndExecute(Message, Action<MessageCollection<T1, T2>>, CancellationToken) method. CancellationToken cancellationToken Cancellation token to stop the wait operation. Returns Type Description Boolean true if the action was executed; otherwise false . | Improve this Doc View Source GetCompleteSets(MessageDomain) Overridden by inheriting classes to get all sets of message for a specific domain without specific type. Declaration protected IEnumerable<MessageCollection> GetCompleteSets(MessageDomain domain) Parameters Type Name Description MessageDomain domain The domain for which sets should be found. Returns Type Description IEnumerable < MessageCollection > An enumeration of all completed sets for the domain. | Improve this Doc View Source IsCompleted(MessageDomain, out MessageCollection) Overridden by inheriting classes to see if there is a completed set for the specified domain. Declaration protected virtual bool IsCompleted(MessageDomain domain, out MessageCollection messageCollection) Parameters Type Name Description MessageDomain domain The domain which should be completed. MessageCollection messageCollection The message collection with the complete set. Returns Type Description Boolean true if there is a completed set; otherwise false | Improve this Doc View Source Push(Message) Add a message to the collector. Declaration public void Push(Message message) Parameters Type Name Description Message message The message object to add. | Improve this Doc View Source PushAndContinue(Message, Action<MessageCollection<T1, T2>>, CancellationToken) Add a message to the collector and continue with the specified action once when the set is found. Declaration public void PushAndContinue(Message message, Action<MessageCollection<T1, T2>> onCollected, CancellationToken cancellationToken = null) Parameters Type Name Description Message message The message which is added to the collector. Action < MessageCollection <T1, T2>> onCollected The action which is executed when the complete set is found. CancellationToken cancellationToken Cancellation token to stop the continue operation. | Improve this Doc View Source PushAndExecute(Message, Action<MessageCollection<T1, T2>>, CancellationToken) Add a message to the collector and wait of the complete set to execute the specified action. Declaration public bool PushAndExecute(Message message, Action<MessageCollection<T1, T2>> onCollected, CancellationToken cancellationToken = null) Parameters Type Name Description Message message The message which is added to the collector. Action < MessageCollection <T1, T2>> onCollected The action which is executed when the complete set is found. CancellationToken cancellationToken Cancellation token to stop the wait operation. Returns Type Description Boolean true if the action was executed; otherwise false . Remarks This method is helpful for InterceptorAgent s where the agent in the InterceptCore(Message) method must wait for a set of message before returning the InterceptionAction . Another example is when the InterceptorAgent wants to wait on a single message. In this case the first message is the message that is intercepted. The second message is the message the agent needs. The advantage is, that the collector respects message domains. | Improve this Doc View Source RemoveMessage(Message) Overriden by inheriting classes to remove the message passed to the method. Declaration protected virtual void RemoveMessage(Message message) Parameters Type Name Description Message message The message to remove from the collector. | Improve this Doc View Source TryGetMessageFittingDomain<T>(MessageDomain, Dictionary<MessageDomain, MessageStore<T>>, out MessageStore<T>) Used to get a message from the message dictionaries. Declaration protected bool TryGetMessageFittingDomain<T>(MessageDomain domain, Dictionary<MessageDomain, MessageStore<T>> messagePool, out MessageStore<T> message) where T : Message Parameters Type Name Description MessageDomain domain The message domain to get the message for. Dictionary < MessageDomain , MessageStore <T>> messagePool The dictionary for the specific message type. MessageStore <T> message The message for the domain. Returns Type Description Boolean true if the dictionary contains a message for the specific domain; otherwise false . Type Parameters Name Description T The type of the message. | Improve this Doc View Source TryPush(Message) Tries to add the message to the collector. Declaration public bool TryPush(Message message) Parameters Type Name Description Message message The message object to add. Returns Type Description Boolean true if the message was added; otherwise false | Improve this Doc View Source UpdateMessagePool<T>(T, Dictionary<MessageDomain, MessageStore<T>>) Add the message to the specified message pool. Declaration protected void UpdateMessagePool<T>(T message, Dictionary<MessageDomain, MessageStore<T>> messagePool) where T : Message Parameters Type Name Description T message The message to add. Dictionary < MessageDomain , MessageStore <T>> messagePool The message pool to add the message to. Type Parameters Name Description T The type of the message."
  },
  "api/Agents.Net.MessageCollector-3.html": {
    "href": "api/Agents.Net.MessageCollector-3.html",
    "title": "Class MessageCollector<T1, T2, T3> | Agents.Net Documentation",
    "keywords": "Class MessageCollector<T1, T2, T3> This is a helper class that collects thread safe all messages until all message types are collected. Inheritance Object MessageCollector <T1, T2> MessageCollector<T1, T2, T3> MessageCollector<T1, T2, T3, T4> Inherited Members MessageCollector<T1, T2>.Messages1 MessageCollector<T1, T2>.Messages2 MessageCollector<T1, T2>.Push(Message) MessageCollector<T1, T2>.TryPush(Message) MessageCollector<T1, T2>.RemoveMessage(Message) MessageCollector<T1, T2>.PushAndExecute(Message, Action<MessageCollection<T1, T2>>, CancellationToken) MessageCollector<T1, T2>.PushAndContinue(Message, Action<MessageCollection<T1, T2>>, CancellationToken) MessageCollector<T1, T2>.ExecutePushAndExecute(Message, Action<MessageCollection>, CancellationToken) MessageCollector<T1, T2>.ExecutePushAndContinue(Message, Action<MessageCollection>, CancellationToken) MessageCollector<T1, T2>.GetCompleteSets(MessageDomain) MessageCollector<T1, T2>.IsCompleted(MessageDomain, MessageCollection) MessageCollector<T1, T2>.TryGetMessageFittingDomain<T>(MessageDomain, Dictionary<MessageDomain, MessageStore<T>>, MessageStore<T>) MessageCollector<T1, T2>.Execute(MessageCollection) MessageCollector<T1, T2>.Aggregate(Message, Boolean) MessageCollector<T1, T2>.UpdateMessagePool<T>(T, Dictionary<MessageDomain, MessageStore<T>>) Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class MessageCollector<T1, T2, T3> : MessageCollector<T1, T2> where T1 : Message where T2 : Message where T3 : Message Type Parameters Name Description T1 T2 T3 Remarks The collector collects messages until all message types are collected. Afterwards it executes an action with the collected MessageCollection . In the following different scenarios are described, which explain the different aspects of this class. Overriding messages Assuming the message of type T1 was collected and T2 was not. When another message of type T1 is collected it replaces the old T1 message with the new message. No action is executed. Considering message domains Assuming the following MessageDomain s and the collected messages: --------------- ------------ | DefaultDomain | ----> | SubDomain1 | --------------- | ------------ T1 Message1 | T1 Message2 | T2 Message4 | | ------------ ----> | SubDomain2 | ------------ T2 Message3 T2 Message5 Here is what happens in this scenario. Message1 is collected. Message2 is collected. This does not override Message1 because it is from a different MessageDomain. It is stored parallel. Message3 is collected. Now SubDomain2 has a complete set of Message1 + Message3. Message 4 is collected. Now there is another completed set in SubDomain1 of Message2 + Message4. Message5 is collected. This overrides Message3 as it is in the same MessageDomain. A new set is executed with Message1 + Message5. In the end the following sets were executed inorder: Message1 + Message3 Message2 + Message4 Message1 + Message5 Consumed vs not consumed messages Messages can be consumed during execution with the method MarkAsConsumed(Message) . The consumed message is removed from the message collector immediately. Looking at the example above the Message1 is used twice. Assuming during the first execution of Message1 + Message3 the agent executed collection.MarkAsConsumed(Message1) . In this case the third execution Message1 + Message5 would not have happened, as Message1 would have been cleared from the collector instance. Constructors | Improve this Doc View Source MessageCollector(Action<MessageCollection<T1, T2, T3>>) Declaration public MessageCollector(Action<MessageCollection<T1, T2, T3>> onMessagesCollected = null) Parameters Type Name Description Action < MessageCollection <T1, T2, T3>> onMessagesCollected Properties | Improve this Doc View Source Messages3 Store for messages of type T3 . Declaration protected Dictionary<MessageDomain, MessageStore<T3>> Messages3 { get; } Property Value Type Description Dictionary < MessageDomain , MessageStore <T3>> Methods | Improve this Doc View Source Aggregate(Message, Boolean) Overridden by inheriting classes to try to add the message to the collector dictionaries. Declaration protected override bool Aggregate(Message message, bool throwError) Parameters Type Name Description Message message The message to add Boolean throwError If set to true , throws an error if the message could not be added. Returns Type Description Boolean true if the message was added to any dictionary; otherwise false . Overrides Agents.Net.MessageCollector<T1, T2>.Aggregate(Agents.Net.Message, System.Boolean) | Improve this Doc View Source Execute(MessageCollection) Overridden by inheriting classes to execute the typeless message collection cast to the specific collector type.. Declaration protected override void Execute(MessageCollection messageCollection) Parameters Type Name Description MessageCollection messageCollection The typeless collection. Overrides Agents.Net.MessageCollector<T1, T2>.Execute(Agents.Net.MessageCollection) | Improve this Doc View Source IsCompleted(MessageDomain, out MessageCollection) Overridden by inheriting classes to see if there is a completed set for the specified domain. Declaration protected override bool IsCompleted(MessageDomain domain, out MessageCollection messageCollection) Parameters Type Name Description MessageDomain domain The domain which should be completed. MessageCollection messageCollection The message collection with the complete set. Returns Type Description Boolean true if there is a completed set; otherwise false Overrides Agents.Net.MessageCollector<T1, T2>.IsCompleted(Agents.Net.MessageDomain, Agents.Net.MessageCollection) | Improve this Doc View Source PushAndContinue(Message, Action<MessageCollection<T1, T2, T3>>, CancellationToken) Add a message to the collector and continue with the specified action once when the set is found. Declaration public void PushAndContinue(Message message, Action<MessageCollection<T1, T2, T3>> onCollected, CancellationToken cancellationToken = null) Parameters Type Name Description Message message The message which is added to the collector. Action < MessageCollection <T1, T2, T3>> onCollected The action which is executed when the complete set is found. CancellationToken cancellationToken Cancellation token to stop the continue operation. | Improve this Doc View Source PushAndExecute(Message, Action<MessageCollection<T1, T2, T3>>, CancellationToken) Add a message to the collector and wait of the complete set to execute the specified action. Declaration public bool PushAndExecute(Message message, Action<MessageCollection<T1, T2, T3>> onCollected, CancellationToken cancellationToken = null) Parameters Type Name Description Message message The message which is added to the collector. Action < MessageCollection <T1, T2, T3>> onCollected The action which is executed when the complete set is found. CancellationToken cancellationToken Cancellation token to stop the wait operation. Returns Type Description Boolean true if the action was executed; otherwise false . Remarks This method is helpful for InterceptorAgent s where the agent in the InterceptCore(Message) method must wait for a set of message before returning the InterceptionAction . Another example is when the InterceptorAgent wants to wait on a single message. In this case the first message is the message that is intercepted. The second message is the message the agent needs. The advantage is, that the collector respects message domains. | Improve this Doc View Source RemoveMessage(Message) Overriden by inheriting classes to remove the message passed to the method. Declaration protected override void RemoveMessage(Message message) Parameters Type Name Description Message message The message to remove from the collector. Overrides Agents.Net.MessageCollector<T1, T2>.RemoveMessage(Agents.Net.Message)"
  },
  "api/Agents.Net.MessageCollector-4.html": {
    "href": "api/Agents.Net.MessageCollector-4.html",
    "title": "Class MessageCollector<T1, T2, T3, T4> | Agents.Net Documentation",
    "keywords": "Class MessageCollector<T1, T2, T3, T4> This is a helper class that collects thread safe all messages until all message types are collected. Inheritance Object MessageCollector <T1, T2> MessageCollector <T1, T2, T3> MessageCollector<T1, T2, T3, T4> MessageCollector<T1, T2, T3, T4, T5> Inherited Members MessageCollector<T1, T2, T3>.Messages3 MessageCollector<T1, T2, T3>.Aggregate(Message, Boolean) MessageCollector<T1, T2, T3>.Execute(MessageCollection) MessageCollector<T1, T2, T3>.IsCompleted(MessageDomain, MessageCollection) MessageCollector<T1, T2, T3>.RemoveMessage(Message) MessageCollector<T1, T2, T3>.PushAndExecute(Message, Action<MessageCollection<T1, T2, T3>>, CancellationToken) MessageCollector<T1, T2, T3>.PushAndContinue(Message, Action<MessageCollection<T1, T2, T3>>, CancellationToken) MessageCollector<T1, T2>.Messages1 MessageCollector<T1, T2>.Messages2 MessageCollector<T1, T2>.Push(Message) MessageCollector<T1, T2>.TryPush(Message) MessageCollector<T1, T2>.RemoveMessage(Message) MessageCollector<T1, T2>.PushAndExecute(Message, Action<MessageCollection<T1, T2>>, CancellationToken) MessageCollector<T1, T2>.PushAndContinue(Message, Action<MessageCollection<T1, T2>>, CancellationToken) MessageCollector<T1, T2>.ExecutePushAndExecute(Message, Action<MessageCollection>, CancellationToken) MessageCollector<T1, T2>.ExecutePushAndContinue(Message, Action<MessageCollection>, CancellationToken) MessageCollector<T1, T2>.GetCompleteSets(MessageDomain) MessageCollector<T1, T2>.IsCompleted(MessageDomain, MessageCollection) MessageCollector<T1, T2>.TryGetMessageFittingDomain<T>(MessageDomain, Dictionary<MessageDomain, MessageStore<T>>, MessageStore<T>) MessageCollector<T1, T2>.Execute(MessageCollection) MessageCollector<T1, T2>.Aggregate(Message, Boolean) MessageCollector<T1, T2>.UpdateMessagePool<T>(T, Dictionary<MessageDomain, MessageStore<T>>) Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class MessageCollector<T1, T2, T3, T4> : MessageCollector<T1, T2, T3> where T1 : Message where T2 : Message where T3 : Message where T4 : Message Type Parameters Name Description T1 T2 T3 T4 Remarks The collector collects messages until all message types are collected. Afterwards it executes an action with the collected MessageCollection . In the following different scenarios are described, which explain the different aspects of this class. Overriding messages Assuming the message of type T1 was collected and T2 was not. When another message of type T1 is collected it replaces the old T1 message with the new message. No action is executed. Considering message domains Assuming the following MessageDomain s and the collected messages: --------------- ------------ | DefaultDomain | ----> | SubDomain1 | --------------- | ------------ T1 Message1 | T1 Message2 | T2 Message4 | | ------------ ----> | SubDomain2 | ------------ T2 Message3 T2 Message5 Here is what happens in this scenario. Message1 is collected. Message2 is collected. This does not override Message1 because it is from a different MessageDomain. It is stored parallel. Message3 is collected. Now SubDomain2 has a complete set of Message1 + Message3. Message 4 is collected. Now there is another completed set in SubDomain1 of Message2 + Message4. Message5 is collected. This overrides Message3 as it is in the same MessageDomain. A new set is executed with Message1 + Message5. In the end the following sets were executed inorder: Message1 + Message3 Message2 + Message4 Message1 + Message5 Consumed vs not consumed messages Messages can be consumed during execution with the method MarkAsConsumed(Message) . The consumed message is removed from the message collector immediately. Looking at the example above the Message1 is used twice. Assuming during the first execution of Message1 + Message3 the agent executed collection.MarkAsConsumed(Message1) . In this case the third execution Message1 + Message5 would not have happened, as Message1 would have been cleared from the collector instance. Constructors | Improve this Doc View Source MessageCollector(Action<MessageCollection<T1, T2, T3, T4>>) Declaration public MessageCollector(Action<MessageCollection<T1, T2, T3, T4>> onMessagesCollected = null) Parameters Type Name Description Action < MessageCollection <T1, T2, T3, T4>> onMessagesCollected Properties | Improve this Doc View Source Messages4 Store for messages of type T4 . Declaration protected Dictionary<MessageDomain, MessageStore<T4>> Messages4 { get; } Property Value Type Description Dictionary < MessageDomain , MessageStore <T4>> Methods | Improve this Doc View Source Aggregate(Message, Boolean) Overridden by inheriting classes to try to add the message to the collector dictionaries. Declaration protected override bool Aggregate(Message message, bool throwError) Parameters Type Name Description Message message The message to add Boolean throwError If set to true , throws an error if the message could not be added. Returns Type Description Boolean true if the message was added to any dictionary; otherwise false . Overrides Agents.Net.MessageCollector<T1, T2, T3>.Aggregate(Agents.Net.Message, System.Boolean) | Improve this Doc View Source Execute(MessageCollection) Overridden by inheriting classes to execute the typeless message collection cast to the specific collector type.. Declaration protected override void Execute(MessageCollection messageCollection) Parameters Type Name Description MessageCollection messageCollection The typeless collection. Overrides Agents.Net.MessageCollector<T1, T2, T3>.Execute(Agents.Net.MessageCollection) | Improve this Doc View Source IsCompleted(MessageDomain, out MessageCollection) Overridden by inheriting classes to see if there is a completed set for the specified domain. Declaration protected override bool IsCompleted(MessageDomain domain, out MessageCollection messageCollection) Parameters Type Name Description MessageDomain domain The domain which should be completed. MessageCollection messageCollection The message collection with the complete set. Returns Type Description Boolean true if there is a completed set; otherwise false Overrides Agents.Net.MessageCollector<T1, T2, T3>.IsCompleted(Agents.Net.MessageDomain, Agents.Net.MessageCollection) | Improve this Doc View Source PushAndContinue(Message, Action<MessageCollection<T1, T2, T3, T4>>, CancellationToken) Add a message to the collector and continue with the specified action once when the set is found. Declaration public void PushAndContinue(Message message, Action<MessageCollection<T1, T2, T3, T4>> onCollected, CancellationToken cancellationToken = null) Parameters Type Name Description Message message The message which is added to the collector. Action < MessageCollection <T1, T2, T3, T4>> onCollected The action which is executed when the complete set is found. CancellationToken cancellationToken Cancellation token to stop the continue operation. | Improve this Doc View Source PushAndExecute(Message, Action<MessageCollection<T1, T2, T3, T4>>, CancellationToken) Add a message to the collector and wait of the complete set to execute the specified action. Declaration public bool PushAndExecute(Message message, Action<MessageCollection<T1, T2, T3, T4>> onCollected, CancellationToken cancellationToken = null) Parameters Type Name Description Message message The message which is added to the collector. Action < MessageCollection <T1, T2, T3, T4>> onCollected The action which is executed when the complete set is found. CancellationToken cancellationToken Cancellation token to stop the wait operation. Returns Type Description Boolean true if the action was executed; otherwise false . Remarks This method is helpful for InterceptorAgent s where the agent in the InterceptCore(Message) method must wait for a set of message before returning the InterceptionAction . Another example is when the InterceptorAgent wants to wait on a single message. In this case the first message is the message that is intercepted. The second message is the message the agent needs. The advantage is, that the collector respects message domains. | Improve this Doc View Source RemoveMessage(Message) Overriden by inheriting classes to remove the message passed to the method. Declaration protected override void RemoveMessage(Message message) Parameters Type Name Description Message message The message to remove from the collector. Overrides Agents.Net.MessageCollector<T1, T2, T3>.RemoveMessage(Agents.Net.Message)"
  },
  "api/Agents.Net.MessageCollector-5.html": {
    "href": "api/Agents.Net.MessageCollector-5.html",
    "title": "Class MessageCollector<T1, T2, T3, T4, T5> | Agents.Net Documentation",
    "keywords": "Class MessageCollector<T1, T2, T3, T4, T5> This is a helper class that collects thread safe all messages until all message types are collected. Inheritance Object MessageCollector <T1, T2> MessageCollector <T1, T2, T3> MessageCollector <T1, T2, T3, T4> MessageCollector<T1, T2, T3, T4, T5> MessageCollector<T1, T2, T3, T4, T5, T6> Inherited Members MessageCollector<T1, T2, T3, T4>.Messages4 MessageCollector<T1, T2, T3, T4>.Aggregate(Message, Boolean) MessageCollector<T1, T2, T3, T4>.Execute(MessageCollection) MessageCollector<T1, T2, T3, T4>.IsCompleted(MessageDomain, MessageCollection) MessageCollector<T1, T2, T3, T4>.RemoveMessage(Message) MessageCollector<T1, T2, T3, T4>.PushAndExecute(Message, Action<MessageCollection<T1, T2, T3, T4>>, CancellationToken) MessageCollector<T1, T2, T3, T4>.PushAndContinue(Message, Action<MessageCollection<T1, T2, T3, T4>>, CancellationToken) MessageCollector<T1, T2, T3>.Messages3 MessageCollector<T1, T2, T3>.Aggregate(Message, Boolean) MessageCollector<T1, T2, T3>.Execute(MessageCollection) MessageCollector<T1, T2, T3>.IsCompleted(MessageDomain, MessageCollection) MessageCollector<T1, T2, T3>.RemoveMessage(Message) MessageCollector<T1, T2, T3>.PushAndExecute(Message, Action<MessageCollection<T1, T2, T3>>, CancellationToken) MessageCollector<T1, T2, T3>.PushAndContinue(Message, Action<MessageCollection<T1, T2, T3>>, CancellationToken) MessageCollector<T1, T2>.Messages1 MessageCollector<T1, T2>.Messages2 MessageCollector<T1, T2>.Push(Message) MessageCollector<T1, T2>.TryPush(Message) MessageCollector<T1, T2>.RemoveMessage(Message) MessageCollector<T1, T2>.PushAndExecute(Message, Action<MessageCollection<T1, T2>>, CancellationToken) MessageCollector<T1, T2>.PushAndContinue(Message, Action<MessageCollection<T1, T2>>, CancellationToken) MessageCollector<T1, T2>.ExecutePushAndExecute(Message, Action<MessageCollection>, CancellationToken) MessageCollector<T1, T2>.ExecutePushAndContinue(Message, Action<MessageCollection>, CancellationToken) MessageCollector<T1, T2>.GetCompleteSets(MessageDomain) MessageCollector<T1, T2>.IsCompleted(MessageDomain, MessageCollection) MessageCollector<T1, T2>.TryGetMessageFittingDomain<T>(MessageDomain, Dictionary<MessageDomain, MessageStore<T>>, MessageStore<T>) MessageCollector<T1, T2>.Execute(MessageCollection) MessageCollector<T1, T2>.Aggregate(Message, Boolean) MessageCollector<T1, T2>.UpdateMessagePool<T>(T, Dictionary<MessageDomain, MessageStore<T>>) Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class MessageCollector<T1, T2, T3, T4, T5> : MessageCollector<T1, T2, T3, T4> where T1 : Message where T2 : Message where T3 : Message where T4 : Message where T5 : Message Type Parameters Name Description T1 T2 T3 T4 T5 Remarks The collector collects messages until all message types are collected. Afterwards it executes an action with the collected MessageCollection . In the following different scenarios are described, which explain the different aspects of this class. Overriding messages Assuming the message of type T1 was collected and T2 was not. When another message of type T1 is collected it replaces the old T1 message with the new message. No action is executed. Considering message domains Assuming the following MessageDomain s and the collected messages: --------------- ------------ | DefaultDomain | ----> | SubDomain1 | --------------- | ------------ T1 Message1 | T1 Message2 | T2 Message4 | | ------------ ----> | SubDomain2 | ------------ T2 Message3 T2 Message5 Here is what happens in this scenario. Message1 is collected. Message2 is collected. This does not override Message1 because it is from a different MessageDomain. It is stored parallel. Message3 is collected. Now SubDomain2 has a complete set of Message1 + Message3. Message 4 is collected. Now there is another completed set in SubDomain1 of Message2 + Message4. Message5 is collected. This overrides Message3 as it is in the same MessageDomain. A new set is executed with Message1 + Message5. In the end the following sets were executed inorder: Message1 + Message3 Message2 + Message4 Message1 + Message5 Consumed vs not consumed messages Messages can be consumed during execution with the method MarkAsConsumed(Message) . The consumed message is removed from the message collector immediately. Looking at the example above the Message1 is used twice. Assuming during the first execution of Message1 + Message3 the agent executed collection.MarkAsConsumed(Message1) . In this case the third execution Message1 + Message5 would not have happened, as Message1 would have been cleared from the collector instance. Constructors | Improve this Doc View Source MessageCollector(Action<MessageCollection<T1, T2, T3, T4, T5>>) Declaration public MessageCollector(Action<MessageCollection<T1, T2, T3, T4, T5>> onMessagesCollected = null) Parameters Type Name Description Action < MessageCollection <T1, T2, T3, T4, T5>> onMessagesCollected Properties | Improve this Doc View Source Messages5 Store for messages of type T5 . Declaration protected Dictionary<MessageDomain, MessageStore<T5>> Messages5 { get; } Property Value Type Description Dictionary < MessageDomain , MessageStore <T5>> Methods | Improve this Doc View Source Aggregate(Message, Boolean) Overridden by inheriting classes to try to add the message to the collector dictionaries. Declaration protected override bool Aggregate(Message message, bool throwError) Parameters Type Name Description Message message The message to add Boolean throwError If set to true , throws an error if the message could not be added. Returns Type Description Boolean true if the message was added to any dictionary; otherwise false . Overrides Agents.Net.MessageCollector<T1, T2, T3, T4>.Aggregate(Agents.Net.Message, System.Boolean) | Improve this Doc View Source Execute(MessageCollection) Overridden by inheriting classes to execute the typeless message collection cast to the specific collector type.. Declaration protected override void Execute(MessageCollection messageCollection) Parameters Type Name Description MessageCollection messageCollection The typeless collection. Overrides Agents.Net.MessageCollector<T1, T2, T3, T4>.Execute(Agents.Net.MessageCollection) | Improve this Doc View Source IsCompleted(MessageDomain, out MessageCollection) Overridden by inheriting classes to see if there is a completed set for the specified domain. Declaration protected override bool IsCompleted(MessageDomain domain, out MessageCollection messageCollection) Parameters Type Name Description MessageDomain domain The domain which should be completed. MessageCollection messageCollection The message collection with the complete set. Returns Type Description Boolean true if there is a completed set; otherwise false Overrides Agents.Net.MessageCollector<T1, T2, T3, T4>.IsCompleted(Agents.Net.MessageDomain, Agents.Net.MessageCollection) | Improve this Doc View Source PushAndContinue(Message, Action<MessageCollection<T1, T2, T3, T4, T5>>, CancellationToken) Add a message to the collector and continue with the specified action once when the set is found. Declaration public void PushAndContinue(Message message, Action<MessageCollection<T1, T2, T3, T4, T5>> onCollected, CancellationToken cancellationToken = null) Parameters Type Name Description Message message The message which is added to the collector. Action < MessageCollection <T1, T2, T3, T4, T5>> onCollected The action which is executed when the complete set is found. CancellationToken cancellationToken Cancellation token to stop the continue operation. | Improve this Doc View Source PushAndExecute(Message, Action<MessageCollection<T1, T2, T3, T4, T5>>, CancellationToken) Add a message to the collector and wait of the complete set to execute the specified action. Declaration public bool PushAndExecute(Message message, Action<MessageCollection<T1, T2, T3, T4, T5>> onCollected, CancellationToken cancellationToken = null) Parameters Type Name Description Message message The message which is added to the collector. Action < MessageCollection <T1, T2, T3, T4, T5>> onCollected The action which is executed when the complete set is found. CancellationToken cancellationToken Cancellation token to stop the wait operation. Returns Type Description Boolean true if the action was executed; otherwise false . Remarks This method is helpful for InterceptorAgent s where the agent in the InterceptCore(Message) method must wait for a set of message before returning the InterceptionAction . Another example is when the InterceptorAgent wants to wait on a single message. In this case the first message is the message that is intercepted. The second message is the message the agent needs. The advantage is, that the collector respects message domains. | Improve this Doc View Source RemoveMessage(Message) Overriden by inheriting classes to remove the message passed to the method. Declaration protected override void RemoveMessage(Message message) Parameters Type Name Description Message message The message to remove from the collector. Overrides Agents.Net.MessageCollector<T1, T2, T3, T4>.RemoveMessage(Agents.Net.Message)"
  },
  "api/Agents.Net.MessageCollector-6.html": {
    "href": "api/Agents.Net.MessageCollector-6.html",
    "title": "Class MessageCollector<T1, T2, T3, T4, T5, T6> | Agents.Net Documentation",
    "keywords": "Class MessageCollector<T1, T2, T3, T4, T5, T6> This is a helper class that collects thread safe all messages until all message types are collected. Inheritance Object MessageCollector <T1, T2> MessageCollector <T1, T2, T3> MessageCollector <T1, T2, T3, T4> MessageCollector <T1, T2, T3, T4, T5> MessageCollector<T1, T2, T3, T4, T5, T6> MessageCollector<T1, T2, T3, T4, T5, T6, T7> Inherited Members MessageCollector<T1, T2, T3, T4, T5>.Messages5 MessageCollector<T1, T2, T3, T4, T5>.Aggregate(Message, Boolean) MessageCollector<T1, T2, T3, T4, T5>.Execute(MessageCollection) MessageCollector<T1, T2, T3, T4, T5>.IsCompleted(MessageDomain, MessageCollection) MessageCollector<T1, T2, T3, T4, T5>.RemoveMessage(Message) MessageCollector<T1, T2, T3, T4, T5>.PushAndExecute(Message, Action<MessageCollection<T1, T2, T3, T4, T5>>, CancellationToken) MessageCollector<T1, T2, T3, T4, T5>.PushAndContinue(Message, Action<MessageCollection<T1, T2, T3, T4, T5>>, CancellationToken) MessageCollector<T1, T2, T3, T4>.Messages4 MessageCollector<T1, T2, T3, T4>.Aggregate(Message, Boolean) MessageCollector<T1, T2, T3, T4>.Execute(MessageCollection) MessageCollector<T1, T2, T3, T4>.IsCompleted(MessageDomain, MessageCollection) MessageCollector<T1, T2, T3, T4>.RemoveMessage(Message) MessageCollector<T1, T2, T3, T4>.PushAndExecute(Message, Action<MessageCollection<T1, T2, T3, T4>>, CancellationToken) MessageCollector<T1, T2, T3, T4>.PushAndContinue(Message, Action<MessageCollection<T1, T2, T3, T4>>, CancellationToken) MessageCollector<T1, T2, T3>.Messages3 MessageCollector<T1, T2, T3>.Aggregate(Message, Boolean) MessageCollector<T1, T2, T3>.Execute(MessageCollection) MessageCollector<T1, T2, T3>.IsCompleted(MessageDomain, MessageCollection) MessageCollector<T1, T2, T3>.RemoveMessage(Message) MessageCollector<T1, T2, T3>.PushAndExecute(Message, Action<MessageCollection<T1, T2, T3>>, CancellationToken) MessageCollector<T1, T2, T3>.PushAndContinue(Message, Action<MessageCollection<T1, T2, T3>>, CancellationToken) MessageCollector<T1, T2>.Messages1 MessageCollector<T1, T2>.Messages2 MessageCollector<T1, T2>.Push(Message) MessageCollector<T1, T2>.TryPush(Message) MessageCollector<T1, T2>.RemoveMessage(Message) MessageCollector<T1, T2>.PushAndExecute(Message, Action<MessageCollection<T1, T2>>, CancellationToken) MessageCollector<T1, T2>.PushAndContinue(Message, Action<MessageCollection<T1, T2>>, CancellationToken) MessageCollector<T1, T2>.ExecutePushAndExecute(Message, Action<MessageCollection>, CancellationToken) MessageCollector<T1, T2>.ExecutePushAndContinue(Message, Action<MessageCollection>, CancellationToken) MessageCollector<T1, T2>.GetCompleteSets(MessageDomain) MessageCollector<T1, T2>.IsCompleted(MessageDomain, MessageCollection) MessageCollector<T1, T2>.TryGetMessageFittingDomain<T>(MessageDomain, Dictionary<MessageDomain, MessageStore<T>>, MessageStore<T>) MessageCollector<T1, T2>.Execute(MessageCollection) MessageCollector<T1, T2>.Aggregate(Message, Boolean) MessageCollector<T1, T2>.UpdateMessagePool<T>(T, Dictionary<MessageDomain, MessageStore<T>>) Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class MessageCollector<T1, T2, T3, T4, T5, T6> : MessageCollector<T1, T2, T3, T4, T5> where T1 : Message where T2 : Message where T3 : Message where T4 : Message where T5 : Message where T6 : Message Type Parameters Name Description T1 T2 T3 T4 T5 T6 Remarks The collector collects messages until all message types are collected. Afterwards it executes an action with the collected MessageCollection . In the following different scenarios are described, which explain the different aspects of this class. Overriding messages Assuming the message of type T1 was collected and T2 was not. When another message of type T1 is collected it replaces the old T1 message with the new message. No action is executed. Considering message domains Assuming the following MessageDomain s and the collected messages: --------------- ------------ | DefaultDomain | ----> | SubDomain1 | --------------- | ------------ T1 Message1 | T1 Message2 | T2 Message4 | | ------------ ----> | SubDomain2 | ------------ T2 Message3 T2 Message5 Here is what happens in this scenario. Message1 is collected. Message2 is collected. This does not override Message1 because it is from a different MessageDomain. It is stored parallel. Message3 is collected. Now SubDomain2 has a complete set of Message1 + Message3. Message 4 is collected. Now there is another completed set in SubDomain1 of Message2 + Message4. Message5 is collected. This overrides Message3 as it is in the same MessageDomain. A new set is executed with Message1 + Message5. In the end the following sets were executed inorder: Message1 + Message3 Message2 + Message4 Message1 + Message5 Consumed vs not consumed messages Messages can be consumed during execution with the method MarkAsConsumed(Message) . The consumed message is removed from the message collector immediately. Looking at the example above the Message1 is used twice. Assuming during the first execution of Message1 + Message3 the agent executed collection.MarkAsConsumed(Message1) . In this case the third execution Message1 + Message5 would not have happened, as Message1 would have been cleared from the collector instance. Constructors | Improve this Doc View Source MessageCollector(Action<MessageCollection<T1, T2, T3, T4, T5, T6>>) Declaration public MessageCollector(Action<MessageCollection<T1, T2, T3, T4, T5, T6>> onMessagesCollected = null) Parameters Type Name Description Action < MessageCollection <T1, T2, T3, T4, T5, T6>> onMessagesCollected Properties | Improve this Doc View Source Messages6 Store for messages of type T6 . Declaration protected Dictionary<MessageDomain, MessageStore<T6>> Messages6 { get; } Property Value Type Description Dictionary < MessageDomain , MessageStore <T6>> Methods | Improve this Doc View Source Aggregate(Message, Boolean) Overridden by inheriting classes to try to add the message to the collector dictionaries. Declaration protected override bool Aggregate(Message message, bool throwError) Parameters Type Name Description Message message The message to add Boolean throwError If set to true , throws an error if the message could not be added. Returns Type Description Boolean true if the message was added to any dictionary; otherwise false . Overrides Agents.Net.MessageCollector<T1, T2, T3, T4, T5>.Aggregate(Agents.Net.Message, System.Boolean) | Improve this Doc View Source Execute(MessageCollection) Overridden by inheriting classes to execute the typeless message collection cast to the specific collector type.. Declaration protected override void Execute(MessageCollection messageCollection) Parameters Type Name Description MessageCollection messageCollection The typeless collection. Overrides Agents.Net.MessageCollector<T1, T2, T3, T4, T5>.Execute(Agents.Net.MessageCollection) | Improve this Doc View Source IsCompleted(MessageDomain, out MessageCollection) Overridden by inheriting classes to see if there is a completed set for the specified domain. Declaration protected override bool IsCompleted(MessageDomain domain, out MessageCollection messageCollection) Parameters Type Name Description MessageDomain domain The domain which should be completed. MessageCollection messageCollection The message collection with the complete set. Returns Type Description Boolean true if there is a completed set; otherwise false Overrides Agents.Net.MessageCollector<T1, T2, T3, T4, T5>.IsCompleted(Agents.Net.MessageDomain, Agents.Net.MessageCollection) | Improve this Doc View Source PushAndContinue(Message, Action<MessageCollection<T1, T2, T3, T4, T5, T6>>, CancellationToken) Add a message to the collector and continue with the specified action once when the set is found. Declaration public void PushAndContinue(Message message, Action<MessageCollection<T1, T2, T3, T4, T5, T6>> onCollected, CancellationToken cancellationToken = null) Parameters Type Name Description Message message The message which is added to the collector. Action < MessageCollection <T1, T2, T3, T4, T5, T6>> onCollected The action which is executed when the complete set is found. CancellationToken cancellationToken Cancellation token to stop the continue operation. | Improve this Doc View Source PushAndExecute(Message, Action<MessageCollection<T1, T2, T3, T4, T5, T6>>, CancellationToken) Add a message to the collector and wait of the complete set to execute the specified action. Declaration public bool PushAndExecute(Message message, Action<MessageCollection<T1, T2, T3, T4, T5, T6>> onCollected, CancellationToken cancellationToken = null) Parameters Type Name Description Message message The message which is added to the collector. Action < MessageCollection <T1, T2, T3, T4, T5, T6>> onCollected The action which is executed when the complete set is found. CancellationToken cancellationToken Cancellation token to stop the wait operation. Returns Type Description Boolean true if the action was executed; otherwise false . Remarks This method is helpful for InterceptorAgent s where the agent in the InterceptCore(Message) method must wait for a set of message before returning the InterceptionAction . Another example is when the InterceptorAgent wants to wait on a single message. In this case the first message is the message that is intercepted. The second message is the message the agent needs. The advantage is, that the collector respects message domains. | Improve this Doc View Source RemoveMessage(Message) Overriden by inheriting classes to remove the message passed to the method. Declaration protected override void RemoveMessage(Message message) Parameters Type Name Description Message message The message to remove from the collector. Overrides Agents.Net.MessageCollector<T1, T2, T3, T4, T5>.RemoveMessage(Agents.Net.Message)"
  },
  "api/Agents.Net.MessageCollector-7.html": {
    "href": "api/Agents.Net.MessageCollector-7.html",
    "title": "Class MessageCollector<T1, T2, T3, T4, T5, T6, T7> | Agents.Net Documentation",
    "keywords": "Class MessageCollector<T1, T2, T3, T4, T5, T6, T7> This is a helper class that collects thread safe all messages until all message types are collected. Inheritance Object MessageCollector <T1, T2> MessageCollector <T1, T2, T3> MessageCollector <T1, T2, T3, T4> MessageCollector <T1, T2, T3, T4, T5> MessageCollector <T1, T2, T3, T4, T5, T6> MessageCollector<T1, T2, T3, T4, T5, T6, T7> Inherited Members MessageCollector<T1, T2, T3, T4, T5, T6>.Messages6 MessageCollector<T1, T2, T3, T4, T5, T6>.Aggregate(Message, Boolean) MessageCollector<T1, T2, T3, T4, T5, T6>.Execute(MessageCollection) MessageCollector<T1, T2, T3, T4, T5, T6>.IsCompleted(MessageDomain, MessageCollection) MessageCollector<T1, T2, T3, T4, T5, T6>.RemoveMessage(Message) MessageCollector<T1, T2, T3, T4, T5, T6>.PushAndExecute(Message, Action<MessageCollection<T1, T2, T3, T4, T5, T6>>, CancellationToken) MessageCollector<T1, T2, T3, T4, T5, T6>.PushAndContinue(Message, Action<MessageCollection<T1, T2, T3, T4, T5, T6>>, CancellationToken) MessageCollector<T1, T2, T3, T4, T5>.Messages5 MessageCollector<T1, T2, T3, T4, T5>.Aggregate(Message, Boolean) MessageCollector<T1, T2, T3, T4, T5>.Execute(MessageCollection) MessageCollector<T1, T2, T3, T4, T5>.IsCompleted(MessageDomain, MessageCollection) MessageCollector<T1, T2, T3, T4, T5>.RemoveMessage(Message) MessageCollector<T1, T2, T3, T4, T5>.PushAndExecute(Message, Action<MessageCollection<T1, T2, T3, T4, T5>>, CancellationToken) MessageCollector<T1, T2, T3, T4, T5>.PushAndContinue(Message, Action<MessageCollection<T1, T2, T3, T4, T5>>, CancellationToken) MessageCollector<T1, T2, T3, T4>.Messages4 MessageCollector<T1, T2, T3, T4>.Aggregate(Message, Boolean) MessageCollector<T1, T2, T3, T4>.Execute(MessageCollection) MessageCollector<T1, T2, T3, T4>.IsCompleted(MessageDomain, MessageCollection) MessageCollector<T1, T2, T3, T4>.RemoveMessage(Message) MessageCollector<T1, T2, T3, T4>.PushAndExecute(Message, Action<MessageCollection<T1, T2, T3, T4>>, CancellationToken) MessageCollector<T1, T2, T3, T4>.PushAndContinue(Message, Action<MessageCollection<T1, T2, T3, T4>>, CancellationToken) MessageCollector<T1, T2, T3>.Messages3 MessageCollector<T1, T2, T3>.Aggregate(Message, Boolean) MessageCollector<T1, T2, T3>.Execute(MessageCollection) MessageCollector<T1, T2, T3>.IsCompleted(MessageDomain, MessageCollection) MessageCollector<T1, T2, T3>.RemoveMessage(Message) MessageCollector<T1, T2, T3>.PushAndExecute(Message, Action<MessageCollection<T1, T2, T3>>, CancellationToken) MessageCollector<T1, T2, T3>.PushAndContinue(Message, Action<MessageCollection<T1, T2, T3>>, CancellationToken) MessageCollector<T1, T2>.Messages1 MessageCollector<T1, T2>.Messages2 MessageCollector<T1, T2>.Push(Message) MessageCollector<T1, T2>.TryPush(Message) MessageCollector<T1, T2>.RemoveMessage(Message) MessageCollector<T1, T2>.PushAndExecute(Message, Action<MessageCollection<T1, T2>>, CancellationToken) MessageCollector<T1, T2>.PushAndContinue(Message, Action<MessageCollection<T1, T2>>, CancellationToken) MessageCollector<T1, T2>.ExecutePushAndExecute(Message, Action<MessageCollection>, CancellationToken) MessageCollector<T1, T2>.ExecutePushAndContinue(Message, Action<MessageCollection>, CancellationToken) MessageCollector<T1, T2>.GetCompleteSets(MessageDomain) MessageCollector<T1, T2>.IsCompleted(MessageDomain, MessageCollection) MessageCollector<T1, T2>.TryGetMessageFittingDomain<T>(MessageDomain, Dictionary<MessageDomain, MessageStore<T>>, MessageStore<T>) MessageCollector<T1, T2>.Execute(MessageCollection) MessageCollector<T1, T2>.Aggregate(Message, Boolean) MessageCollector<T1, T2>.UpdateMessagePool<T>(T, Dictionary<MessageDomain, MessageStore<T>>) Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class MessageCollector<T1, T2, T3, T4, T5, T6, T7> : MessageCollector<T1, T2, T3, T4, T5, T6> where T1 : Message where T2 : Message where T3 : Message where T4 : Message where T5 : Message where T6 : Message where T7 : Message Type Parameters Name Description T1 T2 T3 T4 T5 T6 T7 Remarks The collector collects messages until all message types are collected. Afterwards it executes an action with the collected MessageCollection . In the following different scenarios are described, which explain the different aspects of this class. Overriding messages Assuming the message of type T1 was collected and T2 was not. When another message of type T1 is collected it replaces the old T1 message with the new message. No action is executed. Considering message domains Assuming the following MessageDomain s and the collected messages: --------------- ------------ | DefaultDomain | ----> | SubDomain1 | --------------- | ------------ T1 Message1 | T1 Message2 | T2 Message4 | | ------------ ----> | SubDomain2 | ------------ T2 Message3 T2 Message5 Here is what happens in this scenario. Message1 is collected. Message2 is collected. This does not override Message1 because it is from a different MessageDomain. It is stored parallel. Message3 is collected. Now SubDomain2 has a complete set of Message1 + Message3. Message 4 is collected. Now there is another completed set in SubDomain1 of Message2 + Message4. Message5 is collected. This overrides Message3 as it is in the same MessageDomain. A new set is executed with Message1 + Message5. In the end the following sets were executed inorder: Message1 + Message3 Message2 + Message4 Message1 + Message5 Consumed vs not consumed messages Messages can be consumed during execution with the method MarkAsConsumed(Message) . The consumed message is removed from the message collector immediately. Looking at the example above the Message1 is used twice. Assuming during the first execution of Message1 + Message3 the agent executed collection.MarkAsConsumed(Message1) . In this case the third execution Message1 + Message5 would not have happened, as Message1 would have been cleared from the collector instance. Constructors | Improve this Doc View Source MessageCollector(Action<MessageCollection<T1, T2, T3, T4, T5, T6, T7>>) Declaration public MessageCollector(Action<MessageCollection<T1, T2, T3, T4, T5, T6, T7>> onMessagesCollected = null) Parameters Type Name Description Action < MessageCollection <T1, T2, T3, T4, T5, T6, T7>> onMessagesCollected Properties | Improve this Doc View Source Messages7 Store for messages of type T7 . Declaration protected Dictionary<MessageDomain, MessageStore<T7>> Messages7 { get; } Property Value Type Description Dictionary < MessageDomain , MessageStore <T7>> Methods | Improve this Doc View Source Aggregate(Message, Boolean) Overridden by inheriting classes to try to add the message to the collector dictionaries. Declaration protected override bool Aggregate(Message message, bool throwError) Parameters Type Name Description Message message The message to add Boolean throwError If set to true , throws an error if the message could not be added. Returns Type Description Boolean true if the message was added to any dictionary; otherwise false . Overrides Agents.Net.MessageCollector<T1, T2, T3, T4, T5, T6>.Aggregate(Agents.Net.Message, System.Boolean) | Improve this Doc View Source Execute(MessageCollection) Overridden by inheriting classes to execute the typeless message collection cast to the specific collector type.. Declaration protected override void Execute(MessageCollection messageCollection) Parameters Type Name Description MessageCollection messageCollection The typeless collection. Overrides Agents.Net.MessageCollector<T1, T2, T3, T4, T5, T6>.Execute(Agents.Net.MessageCollection) | Improve this Doc View Source IsCompleted(MessageDomain, out MessageCollection) Overridden by inheriting classes to see if there is a completed set for the specified domain. Declaration protected override bool IsCompleted(MessageDomain domain, out MessageCollection messageCollection) Parameters Type Name Description MessageDomain domain The domain which should be completed. MessageCollection messageCollection The message collection with the complete set. Returns Type Description Boolean true if there is a completed set; otherwise false Overrides Agents.Net.MessageCollector<T1, T2, T3, T4, T5, T6>.IsCompleted(Agents.Net.MessageDomain, Agents.Net.MessageCollection) | Improve this Doc View Source PushAndContinue(Message, Action<MessageCollection<T1, T2, T3, T4, T5, T6, T7>>, CancellationToken) Add a message to the collector and continue with the specified action once when the set is found. Declaration public void PushAndContinue(Message message, Action<MessageCollection<T1, T2, T3, T4, T5, T6, T7>> onCollected, CancellationToken cancellationToken = null) Parameters Type Name Description Message message The message which is added to the collector. Action < MessageCollection <T1, T2, T3, T4, T5, T6, T7>> onCollected The action which is executed when the complete set is found. CancellationToken cancellationToken Cancellation token to stop the continue operation. | Improve this Doc View Source PushAndExecute(Message, Action<MessageCollection<T1, T2, T3, T4, T5, T6, T7>>, CancellationToken) Add a message to the collector and wait of the complete set to execute the specified action. Declaration public bool PushAndExecute(Message message, Action<MessageCollection<T1, T2, T3, T4, T5, T6, T7>> onCollected, CancellationToken cancellationToken = null) Parameters Type Name Description Message message The message which is added to the collector. Action < MessageCollection <T1, T2, T3, T4, T5, T6, T7>> onCollected The action which is executed when the complete set is found. CancellationToken cancellationToken Cancellation token to stop the wait operation. Returns Type Description Boolean true if the action was executed; otherwise false . Remarks This method is helpful for InterceptorAgent s where the agent in the InterceptCore(Message) method must wait for a set of message before returning the InterceptionAction . Another example is when the InterceptorAgent wants to wait on a single message. In this case the first message is the message that is intercepted. The second message is the message the agent needs. The advantage is, that the collector respects message domains. | Improve this Doc View Source RemoveMessage(Message) Overriden by inheriting classes to remove the message passed to the method. Declaration protected override void RemoveMessage(Message message) Parameters Type Name Description Message message The message to remove from the collector. Overrides Agents.Net.MessageCollector<T1, T2, T3, T4, T5, T6>.RemoveMessage(Agents.Net.Message)"
  },
  "api/Agents.Net.MessageDecorator.html": {
    "href": "api/Agents.Net.MessageDecorator.html",
    "title": "Class MessageDecorator | Agents.Net Documentation",
    "keywords": "Class MessageDecorator The base class for message decorators. Inheritance Object Message MessageDecorator Implements IDisposable Inherited Members Message.Id Message.ReplaceWith(Message) Message.SetChild(Message) Message.Is<T>() Message.Get<T>() Message.TryGet<T>(T) Message.MessageDomain Message.ToString() Message.DataToString() Message.Equals(Message) Message.Equals(Object) Message.GetHashCode() Message.DelayDispose() Message.Dispose(Boolean) Message.Dispose() Message.ToMessageLog() Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public abstract class MessageDecorator : Message, IDisposable Remarks This class is the only way to build a hierarchy of messages. This can be done with an InterceptorAgent or by the message producing agent itself. When using Get<T>() the whole hierarchy of message decorators is searched for the specific message type. Examples This is the recommended way of writing a message decorator: public class SpecificMessageDecorator : MessageDecorator { private SpecificMessageDecorator(Message decoratedMessage, IEnumerable<Message> additionalPredecessors = null) : base(decoratedMessage, additionalPredecessors) { } public static SpecificMessageDecorator Decorate(DecoratedMessage declaredMessage, IEnumerable<Message> additionalPredecessors = null) { return new SpecificMessageDecorator(declaredMessage); } protected override string DataToString() { //maybe log additional data } } //Used in client code like this: SpecificMessageDecorator.Decorate(decoratedMessage); Constructors | Improve this Doc View Source MessageDecorator(Message, IEnumerable<Message>) Initializes a new instance of MessageDecorator Declaration protected MessageDecorator(Message decoratedMessage, IEnumerable<Message> additionalPredecessors = null) Parameters Type Name Description Message decoratedMessage The message that should be decorated. IEnumerable < Message > additionalPredecessors The decoratedMessage is automatically the predecessor of this message. With this parameter additional predecessors can be specified. Remarks The decoratedMessage is not necessarily the direct Agents.Net.Message.Child of this message, as it is undetermined which message decorator comes first when two decorators are applied at the same time. But it is thread safe to do so. Methods | Improve this Doc View Source IsDecorated(Message) Checks whether the message is a decorated message or not. Declaration public static bool IsDecorated(Message message) Parameters Type Name Description Message message The message to check. Returns Type Description Boolean true if the message is decorated; otherwise false . Remarks An example when this method can be used is shown in the FileManipulationBenchmark benchmark test. Implements IDisposable"
  },
  "api/Agents.Net.MessageDomain.html": {
    "href": "api/Agents.Net.MessageDomain.html",
    "title": "Class MessageDomain | Agents.Net Documentation",
    "keywords": "Class MessageDomain The time domain the message is operating in. Inheritance Object MessageDomain Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class MessageDomain : IEquatable<MessageDomain> Remarks Each message operates in a specific message domain. Usually that is the DefaultMessageDomain . But there are situations where it is necessary to specify new domains for a message. Some of these situations are: when message are executed explicitly in parallel with OnMessages(IReadOnlyCollection<Message>) in order to aggregate them again when a sequential cycle of recurring message chains is executed in order to identify the start of the cycle when the next cycle starts to separate message produced in a specific chain (e.g. UIEvent) from other messages Given is the following example: --------------- ------------ | DefaultDomain | ----> | SubDomain1 | --------------- | ------------ T1 Message1 | T1 Message2 | T2 Message4 | | ------------ ----> | SubDomain2 | ------------ T2 Message3 T2 Message5 Message2 and Message4 should never be used in SubDomain2 as well as Message3 and Message5 should never be used in SubDomain1. But Message1 is accessible from all domains. The MessageCollector<T1, T2> implements these rules. New messages inherit the domain for their predecessors. That means if there is a new message based on the messages Message1 and Message4 it is automatically in the SubDomain1 as long as that domain is still active. Trying to create a new message based on the messages Message2 and Message3 will result in an exception as these are sibling domains which cannot interfere with each other. Properties | Improve this Doc View Source Children The child domains that were created in this domain. Declaration public IReadOnlyCollection<MessageDomain> Children { get; } Property Value Type Description IReadOnlyCollection < MessageDomain > | Improve this Doc View Source DefaultMessageDomain The default message domain for all new messages. Declaration public static MessageDomain DefaultMessageDomain { get; } Property Value Type Description MessageDomain | Improve this Doc View Source IsTerminated If set to true , shows that the domain was terminated. Declaration public bool IsTerminated { get; } Property Value Type Description Boolean | Improve this Doc View Source Parent The parent domain. Declaration public MessageDomain Parent { get; } Property Value Type Description MessageDomain | Improve this Doc View Source Root The first message of the domain. Declaration public Message Root { get; } Property Value Type Description Message | Improve this Doc View Source SiblingDomainRootMessages The root messages of all message domains that were created together with this domain. Declaration public IReadOnlyCollection<Message> SiblingDomainRootMessages { get; } Property Value Type Description IReadOnlyCollection < Message > Remarks There can be more sibling domains active. This will only contain all sibling domains that were created with the CreateNewDomainsFor(IReadOnlyCollection<Message>) method. Methods | Improve this Doc View Source CreateNewDomainsFor(Message) Create a new domain for the newDomainRootMessage . Declaration public static void CreateNewDomainsFor(Message newDomainRootMessage) Parameters Type Name Description Message newDomainRootMessage The first message in the new domain. | Improve this Doc View Source CreateNewDomainsFor(IReadOnlyCollection<Message>) Create a new domain for each of the newDomainRootMessages . Declaration public static void CreateNewDomainsFor(IReadOnlyCollection<Message> newDomainRootMessages) Parameters Type Name Description IReadOnlyCollection < Message > newDomainRootMessages The first messages in the new domains. | Improve this Doc View Source Equals(MessageDomain) Declaration public bool Equals(MessageDomain other) Parameters Type Name Description MessageDomain other Returns Type Description Boolean | Improve this Doc View Source Equals(Object) Declaration public override bool Equals(object obj) Parameters Type Name Description Object obj Returns Type Description Boolean | Improve this Doc View Source GetHashCode() Declaration public override int GetHashCode() Returns Type Description Int32 | Improve this Doc View Source TerminateDomainsOf(Message) Sets the domain of domainMessage to inactive. Declaration public static void TerminateDomainsOf(Message domainMessage) Parameters Type Name Description Message domainMessage The message which provides the terminated domain. | Improve this Doc View Source TerminateDomainsOf(IReadOnlyCollection<Message>) Sets the domain of all domainMessages to inactive. Declaration public static void TerminateDomainsOf(IReadOnlyCollection<Message> domainMessages) Parameters Type Name Description IReadOnlyCollection < Message > domainMessages The messages which provides the terminated domains. Operators | Improve this Doc View Source Equality(MessageDomain, MessageDomain) Checks whether both domains are equal. Declaration public static bool operator ==(MessageDomain left, MessageDomain right) Parameters Type Name Description MessageDomain left The first domain. MessageDomain right The second domain. Returns Type Description Boolean true , if the domains are equal; otherwise false . | Improve this Doc View Source Inequality(MessageDomain, MessageDomain) Checks whether both domains are not equal. Declaration public static bool operator !=(MessageDomain left, MessageDomain right) Parameters Type Name Description MessageDomain left The first domain. MessageDomain right The second domain. Returns Type Description Boolean true , if the domains are not equal; otherwise false ."
  },
  "api/Agents.Net.MessageGate-2.html": {
    "href": "api/Agents.Net.MessageGate-2.html",
    "title": "Class MessageGate<TStart, TEnd> | Agents.Net Documentation",
    "keywords": "Class MessageGate<TStart, TEnd> This is a helper class which allows to collect a message pair consisting of a start and an end message. Inheritance Object MessageGate<TStart, TEnd> Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class MessageGate<TStart, TEnd> : object where TStart : Message where TEnd : Message Type Parameters Name Description TStart Type of the start message. TEnd Type of the end message. Remarks This helper should be used with caution as it breaks the basic concept of the agent framework, that each agent does exactly one thing. There are only four use cases were this helper should be used. An agent serving as a legacy bridge: When working in a legacy system it is sometimes necessary to have an agent serving a service interface. In this case it is often so that the service call provides some parameters and expects a specific result. To achieve that the service agent needs to wait inside the service call for a specific end message. In addition to that, the service call need to terminate once an exception message was send. It would wait forever otherwise. Use SendAndAwait(TStart, Action<Message>, Int32, CancellationToken) for that use case. When a single agent's task is to handle message pairs: This is necessary for example when handling transactions. In this case the gate can be used to determine whether to rollback the transaction or not. Another example would be when an InterceptorAgent that delays the execution of a message so that an injected message chain can be executed. Use for that use case. When an agent sends multiple messages of the same type and aggregates them: This is explicit parallelization. The work can be split in batches to execute them parallel. The batches can be as small as a single unit of work. This is almost as effective as creating batches based on the amount of available CPU Cores. Use SendAndAggregate(IReadOnlyCollection<TStart>, Action<Message>) for that use case. Calling a simple basic operation inside the agent framework: Let's assume the following use case: The application has a file system abstraction which can execute CRUD operations on files and directories. Now I want to create an agent, that creates a new configuration file. Without this class the solution would look like this: --------------- ------------- -------------------------- | ConfigCreator | ----> | FileCreator | -----> | ConfigFileCreatedWatcher | --------------- ------------- -------------------------- FileCreating FileCreated ConfigFileCreated The ConfigCreator would only create the FileCreating message and mark it somehow for the ConfigFileCreatedWatcher which only marks the FileCreated message. This would unnecessarily increase the amount of agents in the system. With this class the solution would look like this: --------------- ------------- | ConfigCreator | <----> | FileCreator | --------------- ------------- FileCreating FileCreated ConfigFileCreated Similar are operations such as executing an external process or database operations are more examples were the second use case would helpful. Use for that use case. Internally this helper uses MessageCollector<T1, T2> s to execute the boilerplate code. Therefore all information regarding the MessageCollector<T1, T2> applies here to, such as considering message domains. Speaking of domains. The class will internally use a message domain to mark the start message. It is not necessary to do this by the calling code. Examples This example shows the first use case of a legacy service call. [Consumes(typeof(TEnd))] [Consumes(typeof(ExceptionMessage))] [Produces(typeof(TStart))] public class ServiceAgentImplementation : Agent, IService { private readonly MessageGate<TStart,TEnd> gate = new MessageGate<TStart,TEnd>(); public ServiceAgentImplementation(IMessageBoard messageBoard) : base(messageBoard) { } protected override void ExecuteCore(Message messageData) { gate.Check(messageData); } public TResult ServiceCall(TParam parameters) { MessageGateResult<TEnd> result = gate.SendAndAwait(parameters, OnMessage); //evaluate result and return TResult } } Constructors | Improve this Doc View Source MessageGate() Initializes a new instance of MessageGate<TStart, TEnd> Declaration public MessageGate() Fields | Improve this Doc View Source NoTimout A constant value to tell the MessageGate<TStart, TEnd> that it has to wait forever. Declaration public const int NoTimout = null Field Value Type Description Int32 Methods | Improve this Doc View Source Check(Message) Checks whether the provided exception message is the end message or an exception message for the awaited SendAndAwait(TStart, Action<Message>, Int32, CancellationToken) operation. Declaration public bool Check(Message message) Parameters Type Name Description Message message The message to check. Returns Type Description Boolean true , if the message was the end message or an exception message for the SendAndAwait(TStart, Action<Message>, Int32, CancellationToken) operation. Remarks For an example how to use this class see the type documentation. | Improve this Doc View Source SendAndAggregate(IReadOnlyCollection<TStart>, Action<Message>) The method to send the start messages and aggregate all end messages in a MessagesAggregated<T> message. Declaration public void SendAndAggregate(IReadOnlyCollection<TStart> startMessages, Action<Message> onMessage) Parameters Type Name Description IReadOnlyCollection <TStart> startMessages The start messages to send. Action < Message > onMessage The action to send the message. Remarks When a batch of messages is published using the this class they can be united again when all last messages of the execution chain are of the same type or an exception message. -------------- --------------------- ----------------- | SplitMessage | ----> | IntermediateMessage | -----> | FinishedMessage | -------------- --------------------- | ----------------- | | ------------------ *----> | ExceptionMessage | | ------------------ | | ------------------ ----> | OtherEndMessage | ------------------ Looking at the example above it would not be possible to unite the SplitMessages again using this class as at least one IntermediateMessage let to an OtherEndMessage . Here a typical example how to setup and use this method: [Consumes(typeof(FinishedMessage))] [Consumes(typeof(ExceptionMessage))] [Produces(typeof(StartMessage))] public class MessageAggregatorAgent : Agent { private readonly MessageGate<FinishedMessage> gate = new MessageGate<FinishedMessage>(); public MessageAggregatorAgent(IMessageBoard messageBoard) : base(messageBoard) { } protected override void ExecuteCore(Message messageData) { if(gate.Check(messageData)) { return; } //create startMessages gate.SendAndAggregate(startMessages, OnMessage); } } | Improve this Doc View Source SendAndAwait(TStart, Action<Message>, Int32, CancellationToken) The method to send a start message and wait for the end message. Declaration public MessageGateResult<TEnd> SendAndAwait(TStart startMessage, Action<Message> onMessage, int timeout = null, CancellationToken cancellationToken = null) Parameters Type Name Description TStart startMessage The start message. Action < Message > onMessage The action to send the message. Int32 timeout Optionally a timeout after which the method will return, without sending the result. By default the timeout is NoTimout CancellationToken cancellationToken Optionally a cancellation token to cancel the wait operation. This is helpful, when for example the imitated service call is an async method. By default no CancellationToken will be used. Returns Type Description MessageGateResult <TEnd> The MessageGateResult<TEnd> of the operation. Remarks For an example how to use this class see the type documentation. WARNING: Extensive use of this method will lead to time gaps in the execution. See .net issue on github: https://github.com/dotnet/runtime/issues/55562 Use this method only for the legacy service call. Of all other scenarios use . | Improve this Doc View Source SendAndContinue(TStart, Action<Message>, Action<MessageGateResult<TEnd>>, Int32, CancellationToken) The method to send a start message and wait for the end message. Declaration public void SendAndContinue(TStart startMessage, Action<Message> onMessage, Action<MessageGateResult<TEnd>> continueAction, int timeout = null, CancellationToken cancellationToken = null) Parameters Type Name Description TStart startMessage The start message. Action < Message > onMessage The action to send the message. Action < MessageGateResult <TEnd>> continueAction The action to execute once a MessageGateResult<TEnd> was created. Int32 timeout Optionally a timeout after which the method will return, without sending the result. By default the timeout is NoTimout CancellationToken cancellationToken Optionally a cancellation token to cancel the continue operation. By default no CancellationToken will be used. Remarks For an example how to use this class see the type documentation. | Improve this Doc View Source SendAndContinue(IReadOnlyCollection<TStart>, Action<Message>, Action<MessageAggregationResult<TEnd>>, Int32, CancellationToken) The method to send the start messages and wait for all end messages. Declaration public void SendAndContinue(IReadOnlyCollection<TStart> startMessages, Action<Message> onMessage, Action<MessageAggregationResult<TEnd>> onAggregated, int timeout = null, CancellationToken cancellationToken = null) Parameters Type Name Description IReadOnlyCollection <TStart> startMessages The start messages to send. Action < Message > onMessage The action to send the message. Action < MessageAggregationResult <TEnd>> onAggregated The action to execute once a MessageAggregationResult<TEnd> was created. Int32 timeout Optionally a timeout after which the method will return, without sending the result. By default the timeout is NoTimout CancellationToken cancellationToken Optionally a cancellation token to cancel the continue operation. By default no CancellationToken will be used. Remarks When a batch of messages is published using the this class they can be united again when all last messages of the execution chain are of the same type or an exception message. -------------- --------------------- ----------------- | SplitMessage | ----> | IntermediateMessage | -----> | FinishedMessage | -------------- --------------------- | ----------------- | | ------------------ *----> | ExceptionMessage | | ------------------ | | ------------------ ----> | OtherEndMessage | ------------------ Looking at the example above it would not be possible to unite the SplitMessages again using this class as at least one IntermediateMessage let to an OtherEndMessage . This function is useful when the aggregated end messages need to be modified - for example filtered - before aggregating them. In all other cases it is better to use SendAndAggregate(IReadOnlyCollection<TStart>, Action<Message>) to automatically create and send an aggregated message. This is an example, how to use this method correctly: [Consumes(typeof(FinishedMessage))] [Consumes(typeof(ExceptionMessage))] [Produces(typeof(StartMessage))] [Produces(typeof(AggregatedMessage))] public class MessageAggregatorAgent : Agent { private readonly MessageGate<FinishedMessage> gate = new MessageGate<FinishedMessage>(); public MessageAggregatorAgent(IMessageBoard messageBoard) : base(messageBoard) { } protected override void ExecuteCore(Message messageData) { if(gate.Check(messageData)) { return; } //create startMessages gate.SendAndContinue(startMessages, OnMessage, result => { //manipulate the results and produce aggregated message OnMessage(aggregatedMessage); }); } }"
  },
  "api/Agents.Net.MessageGateResult-1.html": {
    "href": "api/Agents.Net.MessageGateResult-1.html",
    "title": "Class MessageGateResult<TEnd> | Agents.Net Documentation",
    "keywords": "Class MessageGateResult<TEnd> The result of the SendAndAwait(TStart, Action<Message>, Int32, CancellationToken) method. Inheritance Object MessageGateResult<TEnd> Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class MessageGateResult<TEnd> : object where TEnd : Message Type Parameters Name Description TEnd The type of the end message Remarks See MessageGate<TStart, TEnd> to understand the usage of this class. Constructors | Improve this Doc View Source MessageGateResult(MessageGateResultKind, TEnd, IEnumerable<ExceptionMessage>) Instantiates the class MessageGateResult<TEnd> Declaration public MessageGateResult(MessageGateResultKind result, TEnd endMessage, IEnumerable<ExceptionMessage> exceptions) Parameters Type Name Description MessageGateResultKind result The result kind. TEnd endMessage The end message. IEnumerable < ExceptionMessage > exceptions Exception messages. Properties | Improve this Doc View Source EndMessage The end message. Can be null if the operation was not successful. Declaration public TEnd EndMessage { get; } Property Value Type Description TEnd | Improve this Doc View Source Exceptions Exceptions that were logged during the execution. Declaration public IEnumerable<ExceptionMessage> Exceptions { get; } Property Value Type Description IEnumerable < ExceptionMessage > Remarks The operation stops after the first exception. But it is possible that before the result is instantiated, that the gate received more exceptions. | Improve this Doc View Source Result The result kind. Meaning if the operation was successful or not. Declaration public MessageGateResultKind Result { get; } Property Value Type Description MessageGateResultKind"
  },
  "api/Agents.Net.MessageGateResultKind.html": {
    "href": "api/Agents.Net.MessageGateResultKind.html",
    "title": "Enum MessageGateResultKind | Agents.Net Documentation",
    "keywords": "Enum MessageGateResultKind The result kind of the SendAndAwait(TStart, Action<Message>, Int32, CancellationToken) method. Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public enum MessageGateResultKind : int Remarks See MessageGate<TStart, TEnd> to understand the usage of this enum. Fields Name Description Canceled The operation was canceled by the provided to the SendAndAwait(TStart, Action<Message>, Int32, CancellationToken) method. Exception At least one ExceptionMessage was received during the execution. Success The operation was successful. Meaning the end message was found. Timeout The operation ran into the configured timeout."
  },
  "api/Agents.Net.MessageLog.html": {
    "href": "api/Agents.Net.MessageLog.html",
    "title": "Class MessageLog | Agents.Net Documentation",
    "keywords": "Class MessageLog This class is used to log a message in JSON format. Inheritance Object MessageLog Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class MessageLog : object Remarks It can be used for analysing tests or the log. Constructors | Improve this Doc View Source MessageLog(String, Guid, IEnumerable<Guid>, Guid, String, MessageLog) Initialized a new instance of the class MessageLog . Declaration public MessageLog(string name, Guid id, IEnumerable<Guid> predecessors, Guid domain, string data, MessageLog child) Parameters Type Name Description String name The name of the message. Guid id The message id. IEnumerable < Guid > predecessors The message predecessors. Guid domain The message domain. String data The data string representation. MessageLog child The child, if existing. Properties | Improve this Doc View Source Child Get the MessageLog representation of the child message. Declaration public MessageLog Child { get; } Property Value Type Description MessageLog | Improve this Doc View Source Data The the string representation of the message data. Declaration public string Data { get; } Property Value Type Description String Remarks This is the value for the DataToString() method. | Improve this Doc View Source Domain Get the id of the message domain. Declaration public Guid Domain { get; } Property Value Type Description Guid | Improve this Doc View Source Id Get the id of the message. Declaration public Guid Id { get; } Property Value Type Description Guid | Improve this Doc View Source Name Get the name of the message type. Declaration public string Name { get; } Property Value Type Description String | Improve this Doc View Source Predecessors Get the ids of the predecessor messages. Declaration public IEnumerable<Guid> Predecessors { get; } Property Value Type Description IEnumerable < Guid >"
  },
  "api/Agents.Net.MessagesAggregated-1.html": {
    "href": "api/Agents.Net.MessagesAggregated-1.html",
    "title": "Class MessagesAggregated<T> | Agents.Net Documentation",
    "keywords": "Class MessagesAggregated<T> This is the message that will be send automatically by the SendAndAggregate(IReadOnlyCollection<TStart>, Action<Message>) method. Inheritance Object Message MessagesAggregated<T> Implements IDisposable Inherited Members Message.Id Message.ReplaceWith(Message) Message.SetChild(Message) Message.Is<T>() Message.Get<T>() Message.TryGet<T>(T) Message.MessageDomain Message.ToString() Message.Equals(Message) Message.Equals(Object) Message.GetHashCode() Message.DelayDispose() Message.Dispose(Boolean) Message.Dispose() Message.ToMessageLog() Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public class MessagesAggregated<T> : Message, IDisposable where T : Message Type Parameters Name Description T Properties | Improve this Doc View Source Result The result of the aggregation. Declaration public MessageAggregationResult<T> Result { get; } Property Value Type Description MessageAggregationResult <T> Methods | Improve this Doc View Source DataToString() The method which should be overriden to provide a string representation of the carried data. Declaration protected override string DataToString() Returns Type Description String The string representation. Overrides Message.DataToString() Remarks If used, it should provide a short string as it is logged multiple times. To much data would slow down the application. Implements IDisposable"
  },
  "api/Agents.Net.MessageStore-1.html": {
    "href": "api/Agents.Net.MessageStore-1.html",
    "title": "Class MessageStore<T> | Agents.Net Documentation",
    "keywords": "Class MessageStore<T> A wrapper class for a message that automatically uses DelayDispose() to delay the message disposal until this store is disposed. Inheritance Object MessageStore<T> Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public sealed class MessageStore<T> : IDisposable where T : Message Type Parameters Name Description T The type of the encapsulated message. Constructors | Improve this Doc View Source MessageStore(T) Creates a new instance of MessageStore<T> . Declaration public MessageStore(T message) Parameters Type Name Description T message The message to encapsulate. Remarks It is not necessary to use this constructor as there are implicit and explicit conversions from and to Message . Methods | Improve this Doc View Source Dispose() Declaration public void Dispose() | Improve this Doc View Source FromMessageStore(MessageStore<T>) Explicitly converts from a MessageStore<T> to the encapsulated Message . Declaration public static T FromMessageStore(MessageStore<T> store) Parameters Type Name Description MessageStore <T> store The store to convert. Returns Type Description T The encapsulated message. | Improve this Doc View Source ToMessageStore(T) Explicitly encapsulates a Message in a MessageStore<T> . Declaration public static MessageStore<T> ToMessageStore(T message) Parameters Type Name Description T message The message to encapsulate. Returns Type Description MessageStore <T> The new message store. Operators | Improve this Doc View Source Implicit(T to MessageStore<T>) Implicitly encapsulates a Message in a MessageStore<T> . Declaration public static implicit operator MessageStore<T>(T message) Parameters Type Name Description T message The message to encapsulate. Returns Type Description MessageStore <T> The new message store. | Improve this Doc View Source Implicit(MessageStore<T> to T) Implicitly converts from a MessageStore<T> to the encapsulated Message . Declaration public static implicit operator T(MessageStore<T> store) Parameters Type Name Description MessageStore <T> store The store to convert. Returns Type Description T The encapsulated message."
  },
  "api/Agents.Net.ProducesAttribute.html": {
    "href": "api/Agents.Net.ProducesAttribute.html",
    "title": "Class ProducesAttribute | Agents.Net Documentation",
    "keywords": "Class ProducesAttribute This attribute declares which Message s are produced by the Agent . Inheritance Object ProducesAttribute Namespace : Agents.Net Assembly : Agents.Net.dll Syntax public sealed class ProducesAttribute : Attribute Remarks This attribute is only valid for Agent classes. It serves only for documentation purposes. Constructors | Improve this Doc View Source ProducesAttribute(Type) Initializes a new instance of the ProducesAttribute class. Declaration public ProducesAttribute(Type messageType) Parameters Type Name Description Type messageType The type the the Message that is produced by the Agent . Properties | Improve this Doc View Source MessageType Gets the type of Message that is produced by the Agent . Declaration public Type MessageType { get; } Property Value Type Description Type"
  },
  "articles/agents.net/Benchmarks.html": {
    "href": "articles/agents.net/Benchmarks.html",
    "title": "Minimal overhead | Agents.Net Documentation",
    "keywords": "This page should be updated with each release. This benchmark was made with 2021.6.0. Minimal overhead This benchmark shows the minimal overhead needed to delegate the work to background threads. BenchmarkDotNet=v0.12.1, OS=Windows 10.0.19042 Intel Core i7-8550U CPU 1.80GHz (Kaby Lake R), 1 CPU, 8 logical and 4 physical cores .NET Core SDK=5.0.203 [Host] : .NET Core 3.1.15 (CoreCLR 4.700.21.21202, CoreFX 4.700.21.21402), X64 RyuJIT DefaultJob : .NET Core 3.1.15 (CoreCLR 4.700.21.21202, CoreFX 4.700.21.21402), X64 RyuJIT Method Mean Error StdDev Ratio RatioSD SingleThread 879.3 s 17.54 s 39.60 s 1.00 0.00 ThreadPool 1,951.7 s 35.41 s 33.12 s 2.12 0.11 TaskRun 2,100.1 s 35.64 s 33.33 s 2.28 0.12 Sequential overhead This compares sequential execution - which is the worst case scenario for the framework - of simple single thread execution with the agent framework. Duration -1 means using Thread.SpinWait(15) and 1 means using Thread.Sleep(1) . BenchmarkDotNet=v0.12.1, OS=Windows 10.0.19042 Intel Core i7-8550U CPU 1.80GHz (Kaby Lake R), 1 CPU, 8 logical and 4 physical cores .NET Core SDK=5.0.203 [Host] : .NET Core 3.1.15 (CoreCLR 4.700.21.21202, CoreFX 4.700.21.21402), X64 RyuJIT DefaultJob : .NET Core 3.1.15 (CoreCLR 4.700.21.21202, CoreFX 4.700.21.21402), X64 RyuJIT Method Duration Mean Error StdDev Ratio RatioSD SingleThread -1 695.8 s 12.29 s 18.02 s 1.00 0.00 AgentFramework -1 2,525.7 s 34.86 s 29.11 s 3.59 0.09 AgentFrameworkReusingMessage -1 1,776.0 s 21.11 s 16.48 s 2.52 0.06 SingleThread 1 2,001,126.8 s 3,253.75 s 2,540.31 s 1.00 0.00 AgentFramework 1 1,996,151.6 s 2,506.85 s 2,344.91 s 1.00 0.00 AgentFrameworkReusingMessage 1 1,998,115.7 s 2,298.14 s 2,149.69 s 1.00 0.00 Logging overhead This benchmark shows the sequential overhead when logging is enabled. To make it fair the comparison also logs each cycle in the single thread case. Duration -1 means using Thread.SpinWait(15) and 1 means using Thread.Sleep(1) . BenchmarkDotNet=v0.12.1, OS=Windows 10.0.19042 Intel Core i7-8550U CPU 1.80GHz (Kaby Lake R), 1 CPU, 8 logical and 4 physical cores .NET Core SDK=5.0.203 [Host] : .NET Core 3.1.15 (CoreCLR 4.700.21.21202, CoreFX 4.700.21.21402), X64 RyuJIT DefaultJob : .NET Core 3.1.15 (CoreCLR 4.700.21.21202, CoreFX 4.700.21.21402), X64 RyuJIT Method Duration Mean Error StdDev Ratio RatioSD SingleThread -1 2.084 ms 0.0406 ms 0.0417 ms 1.00 0.00 AgentFramework -1 31.059 ms 0.7493 ms 2.1619 ms 14.12 1.01 SingleThread 1 2,001.834 ms 6.6619 ms 5.2012 ms 1.00 0.00 AgentFramework 1 2,004.502 ms 12.5968 ms 11.1667 ms 1.00 0.01 Parallel execution This benchmark executes 2000 workloads parallel. It compares the agent framework with Parallel.ForEach - which should be the gold standard - and sequential execution. BenchmarkDotNet=v0.12.1, OS=Windows 10.0.19042 Intel Core i7-8550U CPU 1.80GHz (Kaby Lake R), 1 CPU, 8 logical and 4 physical cores .NET Core SDK=5.0.203 [Host] : .NET Core 3.1.15 (CoreCLR 4.700.21.21202, CoreFX 4.700.21.21402), X64 RyuJIT DefaultJob : .NET Core 3.1.15 (CoreCLR 4.700.21.21202, CoreFX 4.700.21.21402), X64 RyuJIT Method Mean Error StdDev Median Ratio SingleThread 11,437.8 ms 44.23 ms 41.37 ms 11,440.4 ms 1.00 ParallelForEach 493.3 ms 70.48 ms 201.09 ms 414.6 ms 0.07 AgentFramework 425.5 ms 25.89 ms 73.45 ms 420.7 ms 0.05 File Manipulation This is more of a real life scenario. 2000 files are scanned from which 400 files are manipulated. Again the agent framework is compared to Parallel.ForEach and sequential execution and a combination of the agent framework with Parallel.ForEach . BenchmarkDotNet=v0.12.1, OS=Windows 10.0.19042 Intel Core i7-8550U CPU 1.80GHz (Kaby Lake R), 1 CPU, 8 logical and 4 physical cores .NET Core SDK=5.0.203 [Host] : .NET Core 3.1.15 (CoreCLR 4.700.21.21202, CoreFX 4.700.21.21402), X64 RyuJIT DefaultJob : .NET Core 3.1.15 (CoreCLR 4.700.21.21202, CoreFX 4.700.21.21402), X64 RyuJIT Method Mean Error StdDev Median Ratio RatioSD SingleThread 308.78 ms 6.080 ms 12.419 ms 308.97 ms 1.00 0.00 ParallelForEach 88.10 ms 2.270 ms 6.586 ms 87.23 ms 0.28 0.03 AgentFramework 112.81 ms 2.235 ms 6.042 ms 112.91 ms 0.37 0.02 AgentFrameworkParallelForEach 90.47 ms 2.852 ms 8.136 ms 87.67 ms 0.29 0.03"
  },
  "articles/agents.net/Getting-Started.html": {
    "href": "articles/agents.net/Getting-Started.html",
    "title": "Contents | Agents.Net Documentation",
    "keywords": "<!-- TODO replace references to framework classes with links. --> In this guide you will learn all basics that are necessary to install and use Agents.Net. Additionally while going through the guide you will learn about the basic concepts used in Agents.Net like agents, messages and so on. Contents Concept Installation Scenario Implementation Preparation Implementing the community Creating messages Creating Agents Gluing it all together Execute the program Further Resources Concept The basic idea of the framework is this. Each agent does one thing (connects to a database, reads console input, verifies some values, ...). For that it needs specific information (location of the database, the raw console input, ...). Additionally it provides all the information it knows (the active database connection, single console arguments and their values, ...). All information are handled in for of messages. The agent is not concerned where the information comes from or who needs the information provided. Based on that idea alone the system will organize all agents automatically simply based on who needs a specific information which was provided. Installation To use the current release simply add it via NuGet: dotnet add package Agents.Net To use to latest version from master use the latest NuGet package from github: Authenticating to github packages for this repository Add package via NuGet nuget install Agents.Net -prerelease Scenario The image above shows the scenario that we are about to implement in this guide. The illustration of the agent community was generated with the Agents.Net.Designer which is currently still in its early alpha state. In this guide we will not use the designer but implement the community ourselves. The goal of the community is to print \"Hello World\" to the console. But it will not do it directly. Rather at the start there are two agents ( HelloAgent and WorldAgent ), which provide the two words for the console. The ConsoleMessageJoiner combines both words to the sentence \"Hello World\" and finally the ConsoleMessageDisplayAgent will print the message to the console and terminate the program. Implementation In this chapter we will implement the above defined scenario. Preparation Create a new .NET Core Console application named \"HelloWorldApp\" In the directory of the HelloWorldApp.csproj execute the command dotnet add package Agents.Net Open the project in your favorite IDE Implementing the community Creating messages Create the message classes HelloConsoleMessage , WorldConsoleMessage and ConsoleMessageCreated with the following content public class <MessageName>: Message { public <MessageName>(string message, Message predecessorMessage) : base(predecessorMessage) { Message = message; } public <MessageName>(string message, IEnumerable<Message> predecessorMessages) : base(predecessorMessages) { Message = message; } public string Message { get; } protected override string DataToString() { return $\"{nameof(Message)}: {Message}\"; } } What are messages? Messages are the communication/data objects that are passed between agents. Agents never interact directly with each other. All messages - except the InitializeMessage - have one or more predecessor messages. These are the messages that led to the current instance. More on that later in an example. Each message can contain additional information beside their semantical one - meaning the information that is transfered by their type. In this example the messages have the Message property as an additional information. In the DataToString method the additional information are stringyfied. This is useful to have better logs - more on that later too. Creating Agents 1. Create the class HelloAgent with the following content [Consumes(typeof(InitializeMessage))] [Produces(typeof(HelloConsoleMessage))] public class HelloAgent : Agent { public HelloAgent(IMessageBoard messageBoard) : base(messageBoard) { } protected override void ExecuteCore(Message messageData) { OnMessage(new HelloConsoleMessage(\"Hello\", messageData)); } } What are agents? Agents are the acting objects in the system. All logic is contained within agents and only agents should execute any logic. They need specific information in form of messages. In this example the agent needs the InitializeMessage as a trigger to execute its code. Additionally agents produce messages about the logic that was executed, containing the data that was generated. In this case the agent produces a HelloConsoleMessage with the data \"Hello\". 2. Create the class WorldAgent with the following content [Consumes(typeof(InitializeMessage))] [Produces(typeof(WorldConsoleMessage))] public class WorldAgent : Agent { public WorldAgent(IMessageBoard messageBoard) : base(messageBoard) { } protected override void ExecuteCore(Message messageData) { OnMessage(new WorldConsoleMessage(\"World\", messageData)); } } What is implicit parallel execution? The agent framework allows for implicit parallel execution. In case of this scenario, the HelloAgent as well as the WorldAgent will react on the InitializeMessage that is send, when the message board starts. That means both agents can do their work parallel, although no code explicitly specifies that they can. The message board is designed in a way that these accidental potentials for parallel execution are used - meaning both agents will run parallel. 3. Create the class ConsoleMessageJoiner with the following content [Consumes(typeof(WorldConsoleMessage))] [Consumes(typeof(HelloConsoleMessage))] [Produces(typeof(ConsoleMessageCreated))] public class ConsoleMessageJoiner : Agent { private readonly MessageCollector<HelloConsoleMessage, WorldConsoleMessage> collector; public ConsoleMessageJoiner(IMessageBoard messageBoard) : base(messageBoard) { collector = new MessageCollector<HelloConsoleMessage, WorldConsoleMessage>(OnMessagesCollected); } private void OnMessagesCollected(MessageCollection<HelloConsoleMessage, WorldConsoleMessage> set) { OnMessage(new ConsoleMessageCreated($\"{set.Message1.Message} {set.Message2.Message}\", set)); } protected override void ExecuteCore(Message messageData) { collector.Push(messageData); } } How to safely consume more than one message? The class above does consume two messages HelloConsoleMessage and WorldConsoleMessage . It is impossible to tell when an agent receives a specific message. It is possible to publish 1.000 messages at once. But the order in which they are executed is completely dependent on the whims of the ThreadPool . Additionally, it is possible that any agent object executes multiple messages parallel. Because of that it is important to be extra careful, when storing something as a state of an agent. Agents.Net comes with two helper classes for this case: MessageCollector and MessageAggregator . In this scenario we will only use the MessageCollector to safely collect the two consumed messages. Only when both messages were received, the passed action will be executed. In this example we see the definition for the predecessor messages. In the first two agents above there was only one predecessor message - InitializeMessage . Now with the collector, the message has two predecessor message HelloConsoleMessage and WorldConsoleMessage . The predecessors are important, because the message domain is derived from the predecessors. Message domains are not scope of this guide. 4. Create the class ConsoleMessageDisplayAgent with the following content [Consumes(typeof(ConsoleMessageCreated))] public class ConsoleMessageDisplayAgent : Agent { private readonly Action terminateAction; public ConsoleMessageDisplayAgent(IMessageBoard messageBoard, Action terminateAction) : base(messageBoard) { this.terminateAction = terminateAction; } protected override void ExecuteCore(Message messageData) { Console.WriteLine(messageData.Get<ConsoleMessageCreated>().Message); terminateAction(); } } This agent prints the message that was generated by the ConsoleMessageJoiner to the actual console and afterwards terminates the program by executing the terminateAction . The terminateAction will later be passed to the agent. Gluing it all together Here we will look at all the classes that are necessary to glue together all classes we created previously. For that we will not use a DI framework, as it is easier to show what we need to setup with this. Additionally we will configure Serilog to log the execution as this is important in order to \"debug\" Agents.Net. 1. Add Serilog to the project dotnet add package Serilog dotnet add package Serilog.Sinks.Async dotnet add package Serilog.Sinks.File dotnet add package Serilog.Formatting.Compact 2. Configure Serilog using the following code in the program's main method //Setup logging File.Delete(\"log.json\"); Log.Logger = new LoggerConfiguration() .MinimumLevel.Verbose() .WriteTo.Async(l => l.File(new CompactJsonFormatter(), \"log.json\")) .CreateLogger(); This will ensure that all Agents.Net message are logged - by setting the minimum level to verbose. Additionally this ensures that the impact on the execution time is minimal. 3. Setup the agent community using the following code in the program's main method //Setup community using ManualResetEvent finishedEvent = new(false); IMessageBoard messageBoard = new MessageBoard(); messageBoard.Register(new HelloAgent(messageBoard), new WorldAgent(messageBoard), new ConsoleMessageJoiner(messageBoard), new ConsoleMessageDisplayAgent(messageBoard, () => finishedEvent.Set())); 4. Write start code in the program's main method //Run messageBoard.Start(); Execute the program Look into the execution log Here is the execution log that was generated for the execution of the implemented HelloWorldApp: { \" @t \" : \" 2020-12-24T17:52:51.8534304Z \" , \" @mt \" : \" {@log} \" , \" @l \" : \" Verbose \" , \" log \" :{ \" Agent \" : \" WorldAgent \" , \" Type \" : \" Executing \" , \" AgentId \" : \" 25ca3340-69c0-44b5-a538-0d97299499ec \" , \" Message \" :{ \" Name \" : \" InitializeMessage \" , \" Id \" : \" c163f51a-c19b-42a3-aede-585186324d32 \" , \" Predecessors \" :[], \" Domain \" : \" 3cf6acc6-a852-4c2e-a688-b247a94987eb \" , \" Data \" : \" \" , \" Child \" : null , \" $type \" : \" MessageLog \" }, \" $type \" : \" AgentLog \" }} { \" @t \" : \" 2020-12-24T17:52:51.8534661Z \" , \" @mt \" : \" {@log} \" , \" @l \" : \" Verbose \" , \" log \" :{ \" Agent \" : \" HelloAgent \" , \" Type \" : \" Executing \" , \" AgentId \" : \" c531c6be-d4e0-421c-9bbb-6d64a5f5d7b6 \" , \" Message \" :{ \" Name \" : \" InitializeMessage \" , \" Id \" : \" c163f51a-c19b-42a3-aede-585186324d32 \" , \" Predecessors \" :[], \" Domain \" : \" 3cf6acc6-a852-4c2e-a688-b247a94987eb \" , \" Data \" : \" \" , \" Child \" : null , \" $type \" : \" MessageLog \" }, \" $type \" : \" AgentLog \" }} { \" @t \" : \" 2020-12-24T17:52:51.8586857Z \" , \" @mt \" : \" {@log} \" , \" @l \" : \" Verbose \" , \" log \" :{ \" Agent \" : \" WorldAgent \" , \" Type \" : \" Publishing \" , \" AgentId \" : \" 25ca3340-69c0-44b5-a538-0d97299499ec \" , \" Message \" :{ \" Name \" : \" WorldConsoleMessage \" , \" Id \" : \" ca73e3bf-c380-4753-b7a8-987fca8ab56d \" , \" Predecessors \" :[ \" c163f51a-c19b-42a3-aede-585186324d32 \" ], \" Domain \" : \" 3cf6acc6-a852-4c2e-a688-b247a94987eb \" , \" Data \" : \" Message: World \" , \" Child \" : null , \" $type \" : \" MessageLog \" }, \" $type \" : \" AgentLog \" }} { \" @t \" : \" 2020-12-24T17:52:51.8587656Z \" , \" @mt \" : \" {@log} \" , \" @l \" : \" Verbose \" , \" log \" :{ \" Agent \" : \" HelloAgent \" , \" Type \" : \" Publishing \" , \" AgentId \" : \" c531c6be-d4e0-421c-9bbb-6d64a5f5d7b6 \" , \" Message \" :{ \" Name \" : \" HelloConsoleMessage \" , \" Id \" : \" 78d499a5-c1fc-4ab2-9eec-b882617e1994 \" , \" Predecessors \" :[ \" c163f51a-c19b-42a3-aede-585186324d32 \" ], \" Domain \" : \" 3cf6acc6-a852-4c2e-a688-b247a94987eb \" , \" Data \" : \" Message: Hello \" , \" Child \" : null , \" $type \" : \" MessageLog \" }, \" $type \" : \" AgentLog \" }} { \" @t \" : \" 2020-12-24T17:52:51.8589578Z \" , \" @mt \" : \" {@log} \" , \" @l \" : \" Verbose \" , \" log \" :{ \" Agent \" : \" ConsoleMessageJoiner \" , \" Type \" : \" Executing \" , \" AgentId \" : \" 961faab4-f394-4f70-83d2-79d5117e160d \" , \" Message \" :{ \" Name \" : \" WorldConsoleMessage \" , \" Id \" : \" ca73e3bf-c380-4753-b7a8-987fca8ab56d \" , \" Predecessors \" :[ \" c163f51a-c19b-42a3-aede-585186324d32 \" ], \" Domain \" : \" 3cf6acc6-a852-4c2e-a688-b247a94987eb \" , \" Data \" : \" Message: World \" , \" Child \" : null , \" $type \" : \" MessageLog \" }, \" $type \" : \" AgentLog \" }} { \" @t \" : \" 2020-12-24T17:52:51.8589626Z \" , \" @mt \" : \" {@log} \" , \" @l \" : \" Verbose \" , \" log \" :{ \" Agent \" : \" ConsoleMessageJoiner \" , \" Type \" : \" Executing \" , \" AgentId \" : \" 961faab4-f394-4f70-83d2-79d5117e160d \" , \" Message \" :{ \" Name \" : \" HelloConsoleMessage \" , \" Id \" : \" 78d499a5-c1fc-4ab2-9eec-b882617e1994 \" , \" Predecessors \" :[ \" c163f51a-c19b-42a3-aede-585186324d32 \" ], \" Domain \" : \" 3cf6acc6-a852-4c2e-a688-b247a94987eb \" , \" Data \" : \" Message: Hello \" , \" Child \" : null , \" $type \" : \" MessageLog \" }, \" $type \" : \" AgentLog \" }} { \" @t \" : \" 2020-12-24T17:52:51.8657758Z \" , \" @mt \" : \" {@log} \" , \" @l \" : \" Verbose \" , \" log \" :{ \" Agent \" : \" ConsoleMessageJoiner \" , \" Type \" : \" Publishing \" , \" AgentId \" : \" 961faab4-f394-4f70-83d2-79d5117e160d \" , \" Message \" :{ \" Name \" : \" ConsoleMessageCreated \" , \" Id \" : \" ec45ddf5-2baf-4062-8e22-78f3c498fc05 \" , \" Predecessors \" :[ \" 78d499a5-c1fc-4ab2-9eec-b882617e1994 \" , \" ca73e3bf-c380-4753-b7a8-987fca8ab56d \" ], \" Domain \" : \" 3cf6acc6-a852-4c2e-a688-b247a94987eb \" , \" Data \" : \" Message: Hello World \" , \" Child \" : null , \" $type \" : \" MessageLog \" }, \" $type \" : \" AgentLog \" }} { \" @t \" : \" 2020-12-24T17:52:51.8659039Z \" , \" @mt \" : \" {@log} \" , \" @l \" : \" Verbose \" , \" log \" :{ \" Agent \" : \" ConsoleMessageDisplayAgent \" , \" Type \" : \" Executing \" , \" AgentId \" : \" 67adf5b1-d286-4e3f-9069-07264fafac32 \" , \" Message \" :{ \" Name \" : \" ConsoleMessageCreated \" , \" Id \" : \" ec45ddf5-2baf-4062-8e22-78f3c498fc05 \" , \" Predecessors \" :[ \" 78d499a5-c1fc-4ab2-9eec-b882617e1994 \" , \" ca73e3bf-c380-4753-b7a8-987fca8ab56d \" ], \" Domain \" : \" 3cf6acc6-a852-4c2e-a688-b247a94987eb \" , \" Data \" : \" Message: Hello World \" , \" Child \" : null , \" $type \" : \" MessageLog \" }, \" $type \" : \" AgentLog \" }} This view is optimized for speed as even a short \"Hello World\" will produce quite a bit of logging. To make is easier to read the Agents.Net.LogViewer was created. The log viewer is still in its early alpha state. Still it is possible to use. Here is what the log would look like in the log viewer: Further Resources read the API Documentation take a look at the BDD styled showcase tests ask a question in a new discussion contact us via email try and learn ;-) <!-- MARKDOWN LINKS & IMAGES --> <!-- https://www.markdownguide.org/basic-syntax/#reference-style-links -->"
  },
  "articles/agents.net/Home.html": {
    "href": "articles/agents.net/Home.html",
    "title": "Welcome to agents.net | Agents.Net Documentation",
    "keywords": "Welcome to agents.net agents.net is a .NET class library to easily build self-organizing agents based systems. But that is not all. Beside being another .NET class library it is also a programming technique like test driven development , behavior driven development or domain driven design . It encompasses both the design and the implementation phase and can be combined with almost all other techniques mentioned before. In a sense it reduces the complexity of object oriented programming with all its design patterns but using only two types of classes, agents and messages. Agents in that case are the logic of the program while messages are the communication interfaces between agents. Overall programming with agents.net is easy , intuitive and fast . Please feel free to browse around freely. For those how are new, the Getting Started guide is a good place to start. Beside that we have the benchmarks of the current release documented here as well. <!-- MARKDOWN LINKS & IMAGES --> <!-- https://www.markdownguide.org/basic-syntax/#reference-style-links -->"
  },
  "index.html": {
    "href": "index.html",
    "title": "Agents.Net - build agent based system for .NET | Agents.Net Documentation",
    "keywords": "Agents.Net - build agent based system for .NET Agents.Net is a .NET class library to easily build self-organizing agents based systems. This site combines the documentation for the .Net Class Library as well as all tools related to this framework. Notice This is a site in progress. It is currently only used to show the API Documentation and the Wiki Pages for Agents.Net"
  }
}